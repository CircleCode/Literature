<?xml version="1.0" encoding="utf-8"?>
<?xyl-use href="../Definitions.xyl"?>

<definition xmlns="http://hoa-project.net/xyl/xylophone">
<yield name="chapter">

  <draft />

  <h1 id="Websocket"><em lang="en">Hack book</em><title_break /><code>Websocket</code></h1>

  <p>Le protocole WebSocket permet une communication bidirectionnelle entre un
  client et un serveur. La bibliothèque <code>Hoa\Websocket</code> permet de
  créer un serveur WebSocket.</p>

  <h2 id="Table_des_matieres">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Introduction" for="main-toc">Introduction</h2>

  <h3 id="Full-duplex" for="main-toc">Full-duplex</h3>

  <h3 id="Handshake" for="main-toc"><em lang="en">Handshake</em></h3>

  <h3 id="Frame" for="main-toc"><em lang="en">Frame</em></h3>

  <h3 id="Historique" for="main-toc">Historique</h3>

  <h2 id="Ecrire_un_serveur" for="main-toc">Écrire un serveur</h2>

  <p>La classe <code>Hoa\Websocket\Server</code> permet de
  <strong>manipuler</strong> le protocole WebSocket. La
  <strong>communication</strong> s'effectue à travers un serveur de socket. Nous
  utiliserons la classe <code>Hoa\Socket\Server</code> (de la bibliothèque
  <a href="@lh:chapter=Socket"><code>Hoa\Socket</code></a>) pour remplir ce
  rôle.</p>
  <p>Le protocole WebSocket fonctionne en TCP, ainsi nous allons démarrer un
  serveur WebSocket en local sur le port 8889 :</p>
  <pre><code class="language-php">from('Hoa')
-> import('Socket.Server')
-> import('Websocket.Server');

$server = new Hoa\Websocket\Server(
    new Hoa\Socket\Server('tcp://127.0.0.1:8889')
);</code></pre>
  <p>Maintenant, voyons comment <strong>interagir</strong> avec ce serveur.</p>

  <h3 id="Ecouteurs" for="main-toc">Écouteurs</h3>

  <p>La classe <code>Hoa\Websocket\Server</code> propose six écouteurs :</p>
  <ul>
    <li><code>open</code>, quand une <strong>nouvelle</strong> connexion est
    ouverte ;</li>
    <li><code>message</code>, quand un <strong>message</strong> arrive sur le
    serveur ;</li>
    <li><code>binary-message</code>, quand un message <strong>binaire</strong>
    arrive sur le serveur ;</li>
    <li><code>ping</code>, quand un <strong>ping</strong> arrive sur le
    serveur ;</li>
    <li><code>error</code>, quand une <strong>erreur</strong> s'est
    produite ;</li>
    <li><code>close</code>, quand une connexion se <strong>ferme</strong>.</li>
  </ul>
  <p>Pour les écouteurs <code>message</code> et <code>binary-message</code>, il
  n'y a qu'une seule donnée associée : <code>message</code>, qui contient sans
  surprise le <strong>message</strong> provenant du client.</p>
  <p>Pour l'écouteur <code>ping</code>, nous trouvons aussi la donnée
  <code>message</code>. Notons que le pong se fait
  <strong>automatiquement</strong> avant de déclencher l'écouteur.</p>
  <p>Pour l'écouteur <code>error</code>, nous trouvons la donnée
  <code>exception</code> qui contient une <strong>exception</strong> (pas
  nécessairement <code>Hoa\Websocket\Exception</code>, cela peut-être par
  exemple <code>Hoa\Socket\Exception</code>). L'écouteur est déclenché après que
  la connexion avec le client ait été fermée.</p>
  <p>L'écouteur <code>close</code> a deux données associées : <code>code</code>
  pour le <strong>code</strong> et <code>reason</code> qui explique la
  <strong>raison</strong> de cette fermeture avec un message court.  Nous
  trouverons les codes de fermetures standards sous forme de constantes
  <code>CLOSE_<em>*</em></code> sur la classe <code>Hoa\Websocket\Server</code>.
  Par exemple, <code>Hoa\Websocket\Server::CLOSE_NORMAL</code> symbolise une
  fermeture de connexion normale, sans erreur, alors que
  <code>Hoa\Websocket\Server::CLOSE_MESSAGE_ERROR</code> symbolise une fermeture
  de connexion suite à un message mal formé. Cet écouteur est déclenché après
  que la connexion ait été fermée.</p>

  <h3 id="Echanges_de_messages" for="main-toc">Échanges de messages</h3>

  <p>Attaquons maintenant notre exemple. Dans l'écouteur <code>message</code>,
  nous voulons <strong>renvoyer</strong> au client tous les messages qu'il nous
  envoie, de façon à créer un <strong>écho</strong>. Pour cela, nous allons
  utiliser la méthode <code>Hoa\Websocket\Server::send</code>. Une fois que
  notre écouteur est positionné, nous pouvons démarrer le serveur à l'aide de la
  méthode <code>Hoa\Websocket\Server::run</code>. Ainsi :</p>
  <pre data-line="6"><code class="language-php">$server->on('message', function ( Hoa\Core\Event\Bucket $bucket ) {

    $data = $bucket->getData();

    echo 'message: ', $data['message'], "\n";
    $bucket->getSource()->send($data['message']);

    return;
});

$server->run();</code></pre>
  <p>Nous allons maintenant tester notre serveur en créant un client très
  simple :</p>
  <pre data-line="6,45"><code class="language-markup">&amp;lt;input type="text" id="input" placeholder="Message…" />
&amp;lt;hr />
&amp;lt;pre id="output">&amp;lt;/pre>

&amp;lt;script>
  var host   = 'ws://127.0.0.1:8889';
  var socket = null;
  var input  = document.getElementById('input');
  var output = document.getElementById('output');
  var print  = function ( message ) {

      var samp       = document.createElement('samp');
      samp.innerHTML = message + '\n';
      output.appendChild(samp);

      return;
  };

  input.addEventListener('keyup', function ( evt ) {

      if(13 === evt.keyCode) {

          var msg = input.value;

          if(!msg)
              return;

          try {

              socket.send(msg);
              input.value = '';
              input.focus();
          }
          catch ( e ) {

              console.log(e);
          }

          return;
      }
  });

  try {

      socket = new WebSocket(host);
      socket.onopen = function ( ) {

          print('connection is opened');
          input.focus();

          return;
      };
      socket.onmessage = function ( msg ) {

          print(msg.data);

          return;
      };
      socket.onclose = function ( ) {

          print('connection is closed');

          return;
      };
  }
  catch ( e ) {

      console.log(e);
  }
&amp;lt;/script></code></pre>
  <p>À la ligne 6, nous déclarons l'adresse du serveur WebSocket en utilisant le
  protocole <code>ws</code>. À la ligne 45, nous utilisons
  l'<a href="https://developer.mozilla.org/en-US/docs/WebSockets/WebSockets_reference/WebSocket">objet
  <code>WebSocket</code></a>, et nous lui attachons des écouteurs, fortement
  semblables à ceux de <code>Hoa\Websocket\Socket</code> !</p>
  <p>Pour tester, il suffit de démarrer le serveur :</p>
  <pre><code class="language-shell">$ php Server.php</code></pre>
  <p>Puis, d'ouvrir le client avec son navigateur préféré. À chaque message
  envoyé au serveur, il nous revient à l'identique, nous avons bien un écho.</p>

  <h3 id="Diffusions_de_messages" for="main-toc">Diffusions de messages</h3>

  <p>Pour l'instant, le client parle avec le serveur et le serveur lui répond,
  mais ça ne reste qu'un <strong>dialogue</strong>. Le serveur a pourtant toutes
  les connexions en mémoire, nous sommes donc capable de
  <strong>diffuser</strong> le message à tous les clients connectés.</p>
  <p>Le serveur de socket <code>Hoa\Socket\Server</code> travaille avec des
  <strong>nœuds</strong>, c'est à dire un objet qui représente une connexion
  ouverte. Dans un écouteur, pour connaître le nœud <strong>courant</strong> qui
  a déclenché l'appel à cet écouteur, nous devons appeler la méthode
  <code>Hoa\Websocket\Server::getServer</code> pour obtenir le serveur de
  socket, puis <code>Hoa\Socket\Server::getCurrentNode</code>. Similairement,
  nous avons la méthode <code>Hoa\Socket\Server::getNodes</code> pour obtenir
  tous les nœuds.</p>
  <p>Pour envoyer un message sur le client, nous avons utilisé la méthode
  <code>Hoa\Websocket\Server::send</code>. Nous allons nous intéressés à ses
  premiers arguments : le message et le nœud qui va recevoir le message. Par
  défaut, nous l'aurons deviné, c'est le nœud courant. Notre objectif sera alors
  le suivant : quand nous recevons un message, nous allons itérer tous les nœuds
  et l'envoyer sur chacun si ce n'est pas le nœud courant :</p>
  <pre><code class="language-php">$server->on('message', function ( Hoa\Core\Event\Bucket $bucket ) {

    $data        = $bucket->getData();
    $message     = $data['message'];

    $self        = $bucket->getSource();
    $currentNode = $self->getServer()->getCurrentNode();
    $nodes       = $self->getServer()->getNodes();

    foreach($nodes as $node)
        if($node !== $currentNode)
            $self->send($message, $node);

    return;
});</code></pre>
  <p>Et voilà ! Redémarrons le serveur, et ouvrons plusieurs clients. Chaque
  message envoyé sera diffusé à <strong>tous</strong> les autres !</p>

  <h3 id="Fermeture" for="main-toc">Fermeture</h3>

  <p>Pour <strong>fermer</strong> la connexion avec le client, nous utilisons la
  méthode <code>Hoa\Websocket\Server::close</code>. Elle est très similaire à
  <code>Hoa\Websocket\Server::send</code>. Ses arguments sont :</p>
  <ul>
    <li><code>code</code> : le <strong>code</strong> de fermeture, voir les
    constantes <code>Hoa\Websocket\Server::CLOSE_<em>*</em></code>
    (<code>CLOSE_NORMAL</code> par défaut) ;</li>
    <li><code>reason</code> : un message court expliquant la
    <strong>raison</strong> de la fermeture (vaut <code>null</code> par
    défaut) ;</li>
    <li><code>node</code> : le <strong>nœud</strong> qui va fermer la connexion
    (<code>null</code>, par défault, indique le nœud courant).</li>
  </ul>
  <p>Par exemple, quand nous recevons le message <code>I love you</code>, nous
  fermerons la connexion en expliquant pourquoi, sinon nous faisons un simple
  écho du message :</p>
  <pre><code class="language-php">$server->on('message', function ( Hoa\Core\Event\Bucket $bucket ) {

    $data = $bucket->getData();

    if('I love you' === $data['message']) {

        $bucket->getSource()->close(
            Hoa\Websocket\Server::CLOSE_NORMAL,
            'Thank you but my heart is always taken, bye bye!'
        );

        return;
    }

    $bucket->getSource()->send($data['message']);

    return;
});</code></pre>
  <p>Nous pouvons modifier notre client pour qu'il nous affiche le code et la
  raison d'une fermeture :</p>
  <pre><code class="language-javascript">      socket.onclose = function ( e ) {

          print(
              'connection is closed (' + e.code + ' ' +
              (e.reason || '—no reason—') + ')'
          );

          return;
      };</code></pre>
  <p>Il est préférable de <strong>toujours</strong> utiliser cette méthode pour
  fermer une connexion plutôt que de fermer directement la connexion TCP.</p>


  <h2 id="Message" for="main-toc">Message</h2>

  <p>Nous avons deux façons d'envoyer des messages : soit en un seul morceau si
  nous avons le message en <strong>entier</strong>, soit en
  <strong>plusieurs</strong> morceaux si nous ne l'avons pas en entier. Notre
  message peut aussi contenir autre chose que du texte, il peut contenir une
  donnée <strong>binaire</strong>. Dans ce cas, nous parlons de messages
  binaires.</p>

  <h3 id="Fragmentation" for="main-toc">Fragmentation</h3>

  <p>Pour envoyer un message en un seul bloc, nous utilisons la méthode
  <code>Hoa\Websocket\Server::send</code> comme nous l'avons vu dans les
  sections précédentes :</p>
  <pre><code class="language-php">$server->on('message', function ( Hoa\Core\Event\Bucket $bucket ) {

    $bucket->getSource()->send('foobar');

    return;
});</code></pre>
  <p>Cette méthode comporte en réalité quatre arguments :</p>
  <ul>
    <li><code>message</code> : le <strong>message</strong> ;</li>
    <li><code>node</code> : le <strong>nœud</strong> qui va envoyer le message
    (<code>null</code>, par défaut, indique le nœud courant) ;</li>
    <li><code>opcode</code> : l'<strong><em>opcode</em></strong>, c'est à dire
    le type de la <em lang="en">frame</em>
    (<code>Hoa\Websocket\Server::OPCODE_TEXT_FRAME</code> par défaut) ;</li>
    <li><code>fin</code> : indique si le message est <strong>terminé</strong> ou
    pas (<code>true</code> par défaut).</li>
  </ul>
  <p>Nous allons utiliser tous les arguments en essayant d'envoyer un message
  <strong>fragmenté</strong>.</p>
  <p>Dans notre exemple, nous avons envoyé un message en entier, ce qui est le
  cas le plus courant. Si nous envoyons un très long message, nous utiliserons
  également cette même méthode. Toutefois, il peut arriver que nous ayons le
  message morceau après morceau et nous sommes alors incapable de l'envoyer en
  entier. Par exemple, si le message, de taille <strong>indéterminée</strong>,
  est lu sur un flux et que nous voulons ensuite l'envoyer au client, nous
  n'allons pas attendre d'avoir tout le message : nous allons envoyé chaque
  morceau directement au client. Dans ce cas, nous parlons de messages
  fragmentés.</p>
  <p>Nous allons utilisé les deux <em>opcodes</em> suivant :
  <code>OPCODE_TEXT_FRAME</code> pour le <strong>premier</strong> fragment, puis
  <code>OPCODE_CONTINUATION_FRAME</code> pour tous les
  <strong>suivants</strong>. À chaque fois, nous allons préciser que le message
  n'est pas <strong>terminé</strong> à l'aide de l'argument <code>fin</code> qui
  sera à <code>false</code>, sauf pour le dernier fragment où <code>fin</code>
  sera à <code>true</code>.</p>
  <p>L'utilisateur final derrière le client ne recevra pas des messages
  fragmentés, mais le message en entier une fois que le dernier fragment aura
  été reçu. Côté serveur, cela nous évite de surcharger la mémoire avec des
  données « en transites » et aussi de surcharger le réseau avec un gros
  message. Nous envoyons les données dès que nous les avons et c'est le client
  qui s'occupe de <strong>reconstituer</strong> le message. Le serveur opère de
  la même façon lorsqu'il reçoit un message fragmenté. Entre deux fragments, le
  serveur peut aussi traiter d'autres tâches. Bref, c'est plus intéressant
  d'utiliser les fragments plutôt que de tamporiser le message.</p>
  <p>Passons à un exemple. Nous allons envoyé le message <code>foobarbaz</code>
  fragmenté en trois parties. Nous pouvons imaginer que nous lisons ces données
  sur une socket par exemple, et que les données viennent au fur et à mesure.
  Ainsi :</p>
  <pre><code class="language-php">$server->on('message', function ( Hoa\Core\Event\Bucket $bucket ) {

    $self = $bucket->getSource();

    $self->send(
        'foo',
        null,
        Hoa\Websocket\Server::OPCODE_TEXT_FRAME,
        false // not the end…
    );
    echo 'sent foo', "\n";
    sleep(1);

    $self->send(
        'bar',
        null,
        Hoa\Websocket\Server::OPCODE_CONTINUATION_FRAME,
        false // not the end…
    );
    echo 'sent bar', "\n";
    sleep(1);

    $self->send(
        'baz',
        null,
        Hoa\Websocket\Server::OPCODE_CONTINUATION_FRAME,
        true // the end!
    );
    echo 'sent baz, over', "\n";
});</code></pre>
  <p>Les instructions <a href="http://php.net/sleep"><code>sleep</code></a>
  permettent d'émuler une latence réseau ou quelque chose du genre. À chaque
  appel de la méthode <code>send</code>, les données sont
  <strong>effectivement</strong> envoyées sur le client, ce n'est pas un tampon
  côté serveur.</p>

  <h3 id="Encodage" for="main-toc">Encodage</h3>

  <p>Tous les messages échangés doivent être au format <strong>UTF-8</strong>
  (voir la <a href="https://tools.ietf.org/html/rfc3629">RFC3629</a>). Si les
  messages provenant du client ne sont pas conformes,
  <code>Hoa\Websocket\Server</code> fermera la connexion de façon appropriée,
  nous n'avons rien à faire de spécial. Par conséquent, tous les messages reçus
  dans nos écouteurs sont au bon encodage.</p>
  <p>En revanche, <code>Hoa\Websocket\Server</code> vérifie que les messages à
  <strong>destination</strong> du client sont dans le bon encodage. Si
  l'encodage n'est pas approprié, alors une exception
  <code>Hoa\Websocket\Exception\InvalidMessage</code> sera levée, ce qui fermera
  la connexion et déclenchera l'écouteur <code>error</code> si elle n'est pas
  capturée à temps.</p>

  <h3 id="Binaire" for="main-toc">Binaire</h3>

  <p>Il est également possible d'envoyer des données <strong>binaires</strong>,
  bien plus <strong>compactes</strong> que des données textuelles. Nous parlons
  alors de messages binaires.  Nous allons toujours utiliser la méthode
  <code>Hoa\Websocket\Server::send</code> mais avec l'<em>opcode</em>
  <code>OPCODE_BINARY_FRAME</code>. Cela n'a de sens que dans l'écouteur
  <code>binary-message</code>, c'est à dire dans un « dialogue binaire » entre
  le client et le serveur. Nous pouvons imaginer le client qui envoie des
  coordonnées et le serveur qui lui en redonne d'autres (échange fort probable
  pour un jeu de plateau par exemple) :</p>
  <pre><code class="language-php">$server->on('binary-message', function ( Hoa\Core\Event\Bucket $bucket ) {

    $data                          = $bucket->getData();
    $message                       = $data['message'];
    $point                         = array();
    list($point['x'], $point['y']) = array_values(unpack('nx/ny', $message));

    // compute a next point.

    $bucket->getSource()->send(
        pack('nn', $point['x'], $point['y']),
        null,
        Hoa\Websocket\Server::OPCODE_BINARY_FRAME
    );
});</code></pre>
  <p>Les fonctions <a href="http://php.net/pack"><code>pack</code></a> et
  <a href="http://php.net/unpack"><code>unpack</code></a> seront des alliés
  précieux dans ce cas.</p>

  <h2 id="Noeud_personnalise" for="main-toc">Nœud personnalisé</h2>


  <h2 id="Conclusion" for="main-toc">Conclusion</h2>

</yield>
</definition>
