<?xml version="1.0" encoding="utf-8"?>
<?xyl-use href="../Definitions.xyl"?>

<definition xmlns="http://hoa-project.net/xyl/xylophone">
<yield name="chapter">

  <h1 id="Core"><em lang="en">Hack book</em><title_break />Compiler</h1>

  <p>Les <strong>compilateurs</strong> permettent d'<strong>analyser</strong> et
  <strong>manipuler</strong>des données <strong>textuelles</strong>.  Leurs
  applications sont très nombreuses. <code>Hoa\Compiler</code> propose de
  manipuler plusieurs compilateurs selon les besoins.</p>

  <h2 id="Table_des_matieres" for="menu-toc">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Introduction" for="main-toc menu-toc">Introduction</h2>

  <blockquote cite="https://secure.wikimedia.org/wikipedia/fr/wiki/Nicolas_Boileau">Ce
  qui se conçoit bien s'énonce clairement, et les mots pour le dire viennent
  aisément.</blockquote>
  <p>Un <strong>langage</strong> est une façon d'exprimer ou de
  <strong>formuler</strong> une <strong>solution</strong> à un
  <strong>problème</strong>. Et des problèmes, il en existe beaucoup. Nous
  lisons et écrivons dans plusieurs langages au quotidien, et certains de ces
  langages sont <strong>interprétés</strong> par des <strong>machines</strong>.
  Cette opération est possible grâce aux <strong>compilateurs</strong>.</p>
  <p>La
  <a href="https://secure.wikimedia.org/wikipedia/fr/wiki/Théorie_des_langages">théorie
  des langages</a> étudie entre autre l'<strong>analyse automatique</strong> de
  ses langages à travers des outils comme des <strong>automates</strong> ou des
  <strong>grammaires</strong>. Il est nécessaire d'avoir un cours détaillé pour
  bien comprendre tous ces concepts.  Toutefois, nous allons essayer de
  <strong>vulgariser</strong> un minimum pour permettre une utilisation correcte
  de <code>Hoa\Compiler</code>.</p>

  <h3 id="Langage_et_grammaire" for="main-toc">Langage et grammaire</h3>

  <p>Un <strong>langage</strong> est un ensemble de <strong>mots</strong>.
  Chaque mot est une <strong>séquence</strong> de <strong>symboles</strong>
  appartenant à un <strong>alphabet</strong>. Un symbole représente la plus
  petite <strong>unité lexicale</strong> d'un langage, il est atomique et nous
  l'appellons <strong>lexème</strong> (ou <em lang="en">tokens</em> en anglais).
  Les séquences de lexèmes représentant les mots sont construites avec des
  <strong>règles</strong>. À partir d'une règle racine, nous pouvons
  <strong>dériver</strong> ses sous-règles, jusqu'à construire un mot. Selon la
  <strong>dérivation</strong> que nous faisons des règles, nous allons obtenir
  différents mots. Par exemple, si nous considérons les règles suivantes :</p>
  <pre><code>    exp ::= exp + exp
          | nombre
 nombre ::= chiffre nombre
          | chiffre
chiffre ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</code></pre>
  <p>La règle racine est <code><em>exp</em></code>. Si nous la dérivons (de
  gauche ) droite et de haut en bas, ou <em lang="en">left-to-right</em> et
  <em lang="en">top-to-bottom</em> en anglais), nous pouvons avoir
  <code><em>exp</em> + <em>exp</em></code> ou <code><em>nombre</em></code> (la
  <strong>disjonction</strong>, <ie /> le « ou », est représenté par le symbole
  « <code>|</code> ») :</p>
  <pre><code>exp + exp | nombre
→ exp + exp
→ ( exp + exp | nombre ) + exp
→ nombre + exp
→ ( chiffre nombre | chiffre ) + exp</code></pre>
  <p>Nous continuons à dériver jusqu'à <strong>éliminer</strong> toutes les
  règles et n'avoir que des <strong>lexèmes</strong> :</p>
  <pre><code>…
→ ( chiffre nombre | chiffre ) + exp
→ chiffre + exp
→ 7 + exp
→ 7 + ( exp + exp | nombre )
→ 7 + nombre
→ 7 + ( chiffre nombre | chiffre )
→ 7 + chiffre nombre
→ 7 + 3 nombre
→ 7 + 3 ( chiffre nombre | chiffre )
→ 7 + 3 chiffre
→ 7 + 3 5</code></pre>
  <p>Avec cette dérivation, nous obtenons le mot <code>7 + 35</code>.</p>
  <p>Un ensemble de règle est appelé une <strong>grammaire</strong>. Et donc,
  une grammaire représente un <strong>langage</strong> !</p>
  <p>Toutefois, nous nous apercevons qu'il existe <strong>plusieurs</strong>
  façon de dériver les règles. En effet, nous avons choisi
  <strong>arbitrairement</strong> une règle lorsqu'une disjonction était
  rencontrée. Si nous voulons vérifier qu'un mot appartient à un langage, cela
  revient à <strong>trouver</strong> une dérivation permettant de construire un
  <strong>mot équivalent</strong>.</p>
  <p>C'est en 1956 qu'a été formulée la
  <a href="https://secure.wikimedia.org/wikipedia/fr/wiki/Hiérarchie_de_Chomsky">hiérarchie
  de Chomsky</a>, classant les grammaires en quatre <strong>niveaux</strong> :</p>
  <ol start="0">
    <li>grammaires <strong>générales</strong>, ou <em lang="en">unrestricted
    grammars</em>, reconnaissants les langages dits de Turing, aucune
    restriction n'est imposée aux règles ;</li>
    <li>grammaires <strong>contextuelles</strong>, ou
    <em lang="en">context-sensitive grammars</em>, reconnaisants les langages
    contextuels ;</li>
    <li>grammaires <strong>algébriques</strong>, ou <em lang="en">context-free
    grammars</em>, reconnaissants les langages algébriques, basés sur automates
    à pile ;</li>
    <li>grammaires <strong>régulières</strong>, ou <em lang="en">regular
    grammars</em>, reconnaissants les langages réguliers.</li>
  </ol>
  <p>Chaque niveau reconnait le niveau suivant. <code>Hoa\Compiler</code> ne
  traite que les langages définis par les grammaires de niveau 2 et 3. Pour
  donner rapidement une idée, les grammaires régulières peuvent s'apparenter aux
  <a href="https://secure.wikimedia.org/wikipedia/fr/wiki/Expression_régulière">expressions
  régulières</a> (comme les <a href="http://pcre.org/">PCRE</a>), bien connues
  des développeurs. Mais les grammaires régulières ne permettent pas par exemple
  de reconnaître des <strong>couples de symboles</strong> (comme des
  parenthèses, des accolades ou des guillemets), alors que les grammaires
  algébriques le permettent (grâce à la notion de piles de lexèmes).</p>

  <h3 id="Reconnaissance_de_mots" for="main-toc">Reconnaissance de mots</h3>

  <p>En général, le processus de compilation débute par deux
  <strong>analyses</strong> : <strong>lexicale</strong> et
  <strong>syntaxique</strong>. Une analyse lexicale consiste à
  <strong>découper</strong> un mot en une <strong>séquence de lexèmes</strong>.
  Cette séquence sera ensuite utilisée par l'analyseur syntaxique afin de
  vérifier que le mot <strong>appartient</strong> au langage.</p>
  <p>Selon la grammaire, la reconnaissance ne sera fera pas de la même manière,
  mais le principe reste le même : prendre les lexèmes les uns après les autres
  dans la séquence et vérifier qu'ils permettent d'<strong>avancer</strong> dans
  la <strong>dérivation</strong> des règles de notre grammaire.</p>
  <p>Les analyses syntaxiques sont aussi classées en
  <strong>catégories</strong> : LL, LR, LALR etc. <code>Hoa\Compiler</code> ne
  propose que des analyseurs syntaxiques LL, pour <em lang="en">Left-to-right
  Leftmost derivation</em>, <ie /> de la plus haute règle vers la plus profonde,
  et les règles sont dérivées de la gauche vers la droite. Là encore, il existe
  des sous-catégories, dont deux que traitent <code>Hoa\Compiler</code> : LL(1)
  et LL(*). D'une manière générale, on parle d'analyseurs syntaxiques
  LL(<em>k</em>) : si un lexème ne permet pas de dériver une règle comme il
  faut, alors l'analyseur peut <strong>revenir</strong> jusqu'à <em>k</em>
  étapes en arrière ; nous parlons aussi de <em lang="en">backtrack</em>.
  Autrement dit, les règles peuvent être <strong>non-déterministes</strong> : à
  chaque fois que nous dérivons une règle de la grammaire, nous avons plusieurs
  choix possibles et l'analyseur peut se tromper, c'est pourquoi il doit parfois
  revenir en arrière. La variable <em>k</em> permet de définir le
  <strong>niveau</strong> de non-déterminisme. Si une grammaire peut être
  analysée par un analyseur syntaxique LL(1), elle est dite
  <strong>déterministe</strong> : à chaque lexème utilisé pour dériver nos
  règles, il n'y a qu'un seul choix possible. Et si nous avons un analyseur
  syntaxique LL(*), cela signifie que la variable <em>k</em> est
  <strong>indéfinie</strong>. L'exemple suivant illustre une grammaire
  déterministe :</p>
  <pre><code></code></pre>
  <p>Et cet exemple illustre une grammaire non-déterministe :</p>
  <pre><code></code></pre>

  <h2 id="Compilateur_de_compilateur_LLk" for="main-toc menu-toc">Compilateur de
  compilateur LL(k)</h2>

  <h3 id="Langage_PP" for="main-toc">Langage PP</h3>

  <h3 id="Traces" for="main-toc">Traces</h3>

  <h3 id="Abstract_Syntax_Tree" for="main-toc"><em lang="en">Abstract Syntax
  Tree</em></h3>

  <h2 id="Compilateur_de_compilateur_LL1" for="main-toc menu-toc">Compilateur de
  compilateur LL(1)</h2>

  <h2 id="Conclusion" for="main-toc menu-toc">Conclusion</h2>

</yield>
</definition>
