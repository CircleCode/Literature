<?xml version="1.0" encoding="utf-8"?>
<?xyl-use href="Definitions.xyl"?>
<?xyl-stylesheet href="UI.css"?>

<document xmlns="http://hoa-project.net/xyl/xylophone">
  <title>Manuel d'apprentissage de Hoa</title>

  <p>Hoa se définit comme étant un ensemble de bibliothèques PHP
  <strong>puissantes</strong>, <strong>rapides</strong>, hautement
  <strong>modulaires</strong>, <strong>sécuritaires</strong>,
  <strong>innovantes</strong> et respectueuses des <strong>standards</strong>.</p>
  <p>Un projet comme Hoa peut s'aborder de plusieurs façons. Un excellent
  point de départ est le manuel d'apprentissage, qui permet de faire
  connaissance rapidement avec le projet : ce qu'il est, ce qu'il fait,
  comment l'utiliser et où il va, sont des questions pertinentes qui trouvent
  des réponses rapides dans ce manuel d'apprentissage, <em>a contrario</em>
  du manuel de références ou documentation API qui sont respectivement un
  manuel détaillé de toutes les fonctionnalités et une documentation
  bas-niveau. Le manuel d'apprentissage ira plus loin en apportant des
  exemples concrets, par exemple sous forme de tutoriels, afin de mieux guider
  la lectrice ou le lecteur dans sa découverte de Hoa.</p>

  <section1 id="Table_des_matieres">
    <title>Table des matières</title>

    <tableofcontents id="main-toc" />
  </section1>

  <section1 id="Introduction" for="main-toc">
    <title>Introduction</title>

    <section2 id="Modus_operandi" for="main-toc">
      <title><em>Modus operandi</em></title>
    </section2>

    <section2 id="Contributions" for="main-toc">
      <title>Contributions</title>
    </section2>
  </section1>

  <section1 id="A_la_decouverte_de_Hoa" for="main-toc">
    <title>À la découverte de Hoa</title>

    <p>Cette section dévoile quelques atouts de Hoa sous la forme de ...</p>

    <section2 id="Trois_principes_fondamentaux" for="main-toc">
      <title>Trois principes fondamentaux</title>

      <p>En tout premier lieu, Hoa se définit comme un <strong>ensemble de
      bibliothèques</strong>. Une bibliothèque est un ensemble de
      <strong>fonctionnalités</strong> autour d'un sujet ou d'un domaine
      précis. La philosophie des bibliothèques est de proposer un
      environnement <strong>propre</strong>, <strong>logique</strong> et
      <strong>intuitif</strong>, dans lequel l'utilisatrice ou l'utilisateur
      peut développer <strong>efficacement</strong>,
      <strong>sereinement</strong> et <strong>rapidement</strong>. En effet, si
      elles sont bien conçues, les bibliothèques apportent un ensemble de
      solutions pour résoudre des problèmes de manières efficaces. Si les
      solutions sont pertinentes, alors le développement sera efficace.
      Ensuite, si les bibliothèques sont en harmonies entre elles, <ie /> si
      elles sont génériques, alors on peut travailler sereinement : on sait
      que modifier un flux par un autre flux ne créera pas de régression dans
      notre programme car les interfaces sont scrupuleusement les mêmes.
      Enfin, comme les bibliothèques sont pensées de la même manière, on
      acquierera des automatismes à l'utilisation et on se surprendra à
      utiliser des bibliothèques sans presque avoir lu la documentation.</p>
      <p>En deuxième lieu, Hoa se veut être un pont entre le monde de la
      <strong>recherche</strong> et le monde de l'<strong>entreprise</strong>.
      En effet, la recherche est à la pointe de la découverte, des solutions,
      des avancées etc., mais elle manque de retour sur ses travaux. <em>A
      contrario</em>, l'entreprise est en contact avec une multitude
      d'utilisateurs et à besoin d'innover.  Alors, Hoa essaye d'apporter des
      solutions venant du milieu de la recherche aux entreprises, ce afin de
      proposer des <strong>retours à la recherche</strong> et de
      l'<strong>innovation aux entreprises</strong>. Ces retours s'expriment
      sous la forme de commentaires, de contraintes ou de besoins. Et les
      innovations s'expriment sous la forme de solutions efficaces,
      performantes, une autre façon d'aborder un problème d'une manière plus
      générique ou plus optimale. Néanmoins, tout cela reste invisible aux
      deux milieux.  Les utilisateurs, d'où qu'ils proviennent, utiliseront
      Hoa et pourront profiter de tous ces échanges enrichissants. On souligne
      que les contributions viennent autant du monde de la recherche que du
      monde de l'entreprise. C'est ce qui fait <strong>la richesse de
      Hoa</strong>. Notons que Hoa est utilisé entre autre par le
      <link href="http://lifc.univ-fcomte.fr">Laboratoire Informatique de
      Franche-Comté</link>, ainsi que par
      l'<link href="http://www.inria.fr">Institut National de Recherche en
      Informatique et en Automatique</link>.</p>
      <p>Enfin, en dernier lieu, Hoa est <strong>développé en PHP</strong>. Ce
      langage est très intéressant. Il apporte une <strong>dynamique</strong>
      rarement rencontré dans d'autres langages. Toutefois, dû à son histoire,
      il se trouve qu'on peut lui reconnaître certaines faiblesses et certains
      manques. Notamment le fait qu'il n'offre pas de réelle bibliothèque
      standard comme le feraient d'autres langages. Hoa pallie à ce problème en
      proposant ses bibliothèques. L'objectif étant de <strong>redécouvrir
      PHP</strong> et de profiter de toute sa puissance. Cette redécouverte de
      PHP sera d'autant plus forte que les solutions apportées par Hoa sont au
      maximum innovantes. Mais n'oublions pas que Hoa propose un <strong>cadre
      de développement</strong> ; ainsi donc vous pourrez développer
      <strong>vos propres bibliothèques</strong> et vous assurer d'une
      certaine pérennité et d'une forte intégration dans tous les projets
      utilisant Hoa.</p>
    </section2>

    <section2 id="Les_points_forts_de_Hoa" for="main-toc">
      <title>Les points forts de Hoa</title>

      <p>Cette section décrit ce que l'on estime être les points forts de
      Hoa.</p>

      <section3 id="Le_noyau" for="main-toc">
        <title>Le noyau</title>

        <p>Le noyau de Hoa est au centre de toutes les bibliothèques, <ie />
        chaque bibliothèque requiert le noyau pour fonctionner. Ce dernier
        propose des fonctionnalités vitales pour le bon fonctionnement des
        bibliothèques et pour assurer une bonne cohésion de leurs
        fonctionnements.</p>
        <p>Tout d'abord, le noyau se charge du pré-chargement et chargement
        des bibliothèques, selon une taxonomie en famille, <ie /> chaque
        bibliothèque définit un paquetage qui appartient à une famille. Par
        exemple, toutes les bibliothèques que Hoa propose appartiennent à la
        famille <code>Hoa</code>. Ainsi, l'exemple suivant permet d'utiliser
        un routeur et un dispatcheur :</p>
        <blockcode language="php">from('Hoa')
-> import('Controller.Router')
-> import('Controller.Dispatcher.Basic');</blockcode>
        <p>Notons que les fichiers sont pré-chargés, c'est à dire qu'ils sont
        en attente d'utilisation. Ainsi, tant que la classe
        <code>Hoa\Controller\Router</code> n'est pas utilisée, le fichier ne
        sera pas chargé. En revanche, si le pré-chargement n'est pas effectué,
        une erreur sera naturellement levée.</p>
        <p>Ensuite, le noyau permet le paramétrage des bibliothèques et des
        classes. Les paramètres peuvent influer sur le comportement qu'aura
        une bibliothèque. Ils s'expriment sous la forme de tableaux et
        se définissent avec des mots-clés et des paramètres. Le langage
        <em>zFormat</em> permet d'exprimer des manipulations sur les
        paramètres. Considérons l'exemple suivant :</p>
        <blockcode>// Mot-clé
  id => 'fOo'

// Paramètre
  cache.file => (:id:lU:).ca</blockcode>
        <p>La valeur du mot-clé est définie par la bibliothèque, le paramètre
        par l'utilisatrice ou l'utilisateur. On remarque l'utilisation du
        <em>zFormat</em> avec <code>(:id:lU:)</code>, ce qui signifie que l'on
        va utiliser le mot-clé <code>id</code> (<code>:id:</code>) et lui
        appliquer deux fonctions : toutes les lettres en minuscules
        (<code>l</code>) et la première lettre en majuscule (<code>U</code>).
        Ainsi, le résultat de cet exemple sera <code>Foo.ca</code>.</p>
        <p>Le <em>zFormat</em> supporte beaucoup de fonctions, cela va de
        simples constantes de temps (<code>(:_Ymd:)</code> exprime une date)
        jusqu'aux fonctions de remplacement (<code>(:keyword:s/r/z/:)</code>
        recherche toutes les occurences de <code>r</code> et les remplace par
        <code>z</code>). Ce format est vraiment puissant, notamment pour
        exprimer des chemins complexes, comme un chemin constitué d'une date :
        <code>/tmp/hoa/(:_Y:)/(:_md:)/(:%anotherParameter:)-(:myId:l).ca</code>
        sera par exemple résolu en
        <code>/tmp/hoa/1970/0101/hello-foo.ca</code> si le paramètre
        <code>anotherParameter</code> vaut <code>hello</code>.</p>
        <p>Le noyau abstrait également tous les chemins de votre programme,
        grâce au protocole <code>hoa://</code>. Ce protocole porte plusieurs
        types de données, mais il faut le voir dans la plupart des cas comme
        une suite de liens symboliques. Par exemple,
        <code>hoa://Application/Public/</code> sera toujours l'accès au
        dossier qui contient les données publiques de votre programme. Ce
        dossier n'est pas forcément dans un dossier <code>Application</code>
        et ne s'appelle pas forcément <code>Public</code>, mais dans votre
        programme, vous direz simplement que ce chemin pointe vers tel
        dossier. Si jamais l'architecture de votre application se voit
        modifiée, alors vous n'aurez qu'à changer la cible du protocole, mais
        en aucun cas vous n'aurez à reprendre votre programme et modifier tous
        les liens. Par défaut, le protocole définit trois racines :</p>
        <ulist>
          <item><code>hoa://Application/</code> concerne votre
          programme ;</item>
          <item><code>hoa://Data/</code> concerne toutes les données de
          votre programme ;</item>
          <item><code>hoa://Library/</code> concerne les bibliothèques de
          Hoa.</item>
        </ulist>
        <p>Par exemple, <code>hoa://Data/Etc/Configuration/</code> contient
        les configurations de votre programme, tout comme
        <code>hoa://Data/Variable/Cache/</code> contient les caches, ou
        <code>hoa://Data/Variable/Database/</code> contient les bases de
        données ou encore <code>hoa://Data/Bin/</code> qui contient des
        binaires pour manipuler votre application. Mais on trouve également
        <code>hoa://Application/Public/</code> précédemment vu ou
        <code>hoa://Application/View/</code> qui contient les vues de votre
        programme. Tous ces chemins n'existent pas nécessairement, ce sont une
        suite de liens symboliques. Naturellement, cela fonctionne en bas-niveau
        dans l'application :</p>
        <blockcode language="php">from('Hoa')
-> import('File.Read');

$file = new Hoa\File\Read('hoa://Data/Temporary/Foo.txt');
echo $file->readAll();</blockcode>
        <p>Ou encore plus bas-niveau :</p>
        <blockcode language="php">require 'hoa://Data/Etc/Configuration/.Cache/HoaTest.php';</blockcode>
        <p>Il est bien évidemment possible, grâce au noyau, de créer vos
        propres liens sur le protocole.</p>
        <p>Le noyau propose également un système d'événement natif à PHP. Il
        est parfois très pratique d'utiliser ce paradigme. Cela permet une
        grande souplesse dans la façon dont les composants de notre programme
        peuvent communiquer entre eux. Ainsi, l'exemple suivant permet
        d'afficher tous les événements provenant des tests lorsqu'ils sont
        exécutés :</p>
        <blockcode language="php">event('hoa://Event/Log/Test/Praspel')
    ->attach(function ( Hoa\Core\Event\Bucket $event ) {

        print_r($event->getData());
    });</blockcode>
      <p>Le noyau fournit encore d'autres fonctionnalités mais on ne
      s'arrêtera qu'aux principales.</p>
      </section3>

      <section3 id="Les_flux" for="main-toc">
        <title>Les flux</title>

        <p>La majorité des langages destinés aux entreprises manipulent des
        flux. PHP, de part sa position de langage glu, est au centre de
        plusieurs technologies et doit donc gérer au mieux les flux.</p>
        <p>Dans Hoa, il existe un mécanisme de gestion de flux très poussé.
        Ainsi, les fichiers, les sockets, certaines chaînes de caractères, le
        terminal etc., sont des flux. Plusieurs catégories de flux existent :
        comme les flux primitifs, les flux composites, les flux structurels,
        les flux d'entrées, de sorties, tampon, verrouillable etc.</p>
        <p>Prenons l'interface <code>Hoa\Stream\IStream\In</code> qui permet
        de manipuler des flux en entrée (soit en lecture), on trouvera alors
        des méthodes comme <code>read</code>, <code>readInteger</code>,
        <code>readFloat</code>, <code>readCharacter</code>,
        <code>readString</code>, <code>readArray</code> etc. On trouvera
        toutes les méthodes inverses sur l'interface
        <code>Hoa\Stream\IStream\Out</code> pour les flux de sorties (soit
        d'écriture), tel que : <code>write</code>, <code>writeInteger</code>
        etc. Mais on trouve également l'interface
        <code>Hoa\Stream\IStream\Structural</code> pour caractériser des flux
        dits structurels, comme des arbres, tels que XML, YAML, JSON etc. On
        trouvera alors les méthodes <code>selectElements</code>,
        <code>selectDescendantElements</code>,
        <code>selectChildElements</code>,
        <code>selectAdjacentSiblingElement</code>, <code>querySelector</code>
        etc.</p>
        <p>Les flux composites sont quant à eux des flux qui contiennent des
        flux. Il est naturel de comprendre qu'un flux XML ne travaille pas
        forcément sur un fichier mais peut travailler sur une socket. Ici, les
        flux primitifs sont les fichiers et les sockets, et le flux composite
        est le flux XML, qui permet d'interpréter le contenu des flux
        primitifs comme étant du XML. Cela implique que si on modifie le flux
        primitif, tout le traitement effectué sur notre fichier XML restera
        inchangé. Encore mieux : le flux JSON, <em>a l'instar</em> du flux
        XML, est composite mais également structurel (en effet, autant XML que
        JSON définissent des arbres). Si un traitement est fait sur un fichier
        qui n'est plus du XML mais du JSON, on modifie simplement la classe
        utilisée pour lire notre flux primitif, mais les opérations de
        traitement qui suivent ne seront pas modifiées. Tout cela grâce aux
        nombreuses interfaces que proposent les flux. Ainsi, l'exemple suivant
        va sélectionner des éléments et lire leur contenu comme des entiers :</p>
        <blockcode language="php">from('Hoa')
-> import('File.Read')
-> import('Xml.Read');

$xml = new Hoa\Xml\Read(
    new Hoa\File\Read('hoa://Data/Temporary/Foo.xml')
);

foreach($xml->querySelectorAll('foo > bar[attr^="ibute"]') as $element)
    echo $element->readAll() . "\n";</blockcode>
      </section3>

      <section3 id="La_securite_et_la_surete" for="main-toc">
        <title>La sécurité et la sûreté</title>

        <p>La sécurité et la sûreté du logiciel est une discipline
        Informatique à part entière. Cela consiste à s'assurer que rien de
        malveillant n'arrivera et que ce qui doit arriver arrivera, ou plus
        trivialement : notre programme fera tout ce qu'on a prévu, ni plus, ni
        moins, et dans de bonnes conditions.</p>
        <p>Pour cela, il existe plusieurs approches, non mutuellement
        exclusives. L'une d'entre elle est le test. Des travaux de recherche
        ont été menés au sein même de Hoa afin de créer un générateur
        automatique de tests unitaires. Cela a donné lieu à la création d'un
        langage d'annotation et de spécification : <em>Praspel</em>. Ce
        langage est conçu pour exprimer des contraintes sur un algorithme et
        y effectuer plusieurs tests, de différents types, de différentes
        natures, à travers différents procédés. Ce langage constitue la base
        de notre générateur automatique de tests unitaires. Un rapport de
        recherche ainsi que des articles ont été publiés autour de ce sujet.
        Des conférences ont également été données.</p>
        <p>Enfin, la sécurité, dans son sens le plus répandu, existe
        bel et bien dans Hoa. Toutes les données utilisateurs sont protégées
        et vérifiées au maximum. Notons que Hoa, dans sa conception, est basé
        sur une forme de discrétion, ce qui est une forme de sécurité. En
        effet, de part son protocole <code>hoa://</code> qui masque tous les
        chemins, si jamais des erreurs apparaissent à l'utilisatrice ou
        l'utilisateur, aucune information ne pourra en être extraite. C'est un
        exemple certes, mais un parmi beaucoup.</p>
      </section3>

      <section3 id="La_modularite" for="main-toc">
        <title>La modularité</title>

        <p>Hoa est conçu pour proposer un environnement propre de
        développement. Cela implique que vous pouvez vous-même développer au
        sein de Hoa, à travers le mécanisme de modularité appelé
        <em>Hoathis</em>. Ce mécanisme permet d'étendre ou d'ajouter des
        fonctionnalités aux bibliothèques standards que propose Hoa. Vous
        pouvez ainsi les utiliser soit dans un programme (en les déclarant
        au même niveau que votre programme), soit dans tous vos programmes (en
        les déclarant au même niveau que les bibliothèques standards).</p>
        <p>De part la conception de Hoa, l'utilisation de vos bibliothèques se
        feront de la même manière que pour les bibliothèques standards.
        Ainsi :</p>
        <blockcode language="php">from('Hoathis')
-> import('Test.Report.Xformat');

event('hoa://Event/Log/Test/Praspel')->attach(
    new Hoathis\Test\Report\Xformat()
);</blockcode>
        <p>On comprend que si flux de rapports de tests utilise les interfaces
        de flux, alors il s'intégrera sans problème au reste de Hoa.</p>
      </section3>

      <section3 id="L-interface_graphique" for="main-toc">
        <title>L'interface graphique</title>

        <p>Un des problèmes majeurs lors de la création d'un programme est
        l'interface graphique. Il existe une multitude de bibliothèques,
        principalement pour <em>micro-templating</em>, mais aucune ne répond
        vraiment aux besoins. Ces besoins sont : dynamicité, modularité et
        extensibilité. Hoa propose un langage d'interface graphique sous forme
        XML qui répond à de très nombreux besoins : <em>XYL</em>.</p>
        <p><em>XYL</em> est un langage d'interface graphique multi-plateforme
        et multi-sortie, <ie /> vous écrivez votre interface graphique une
        seule fois et vous demandez une interprétation particulière : vers un
        navigateur Web de bureau ou de mobile, vers une application native
        bureau ou mobile, vers une tablette, vers un terminal, vers un fichier
        PDF, vers un fichier XML, JSON etc. Quand on parle de
        multi-plateforme, ça sous entend plusieurs systèmes, avec les
        particularités de chacun.</p>
        <p><em>XYL</em> propose un système de <em>yielding</em> qui permet de
        fixer des données dans l'interface graphique de manière dynamique et
        qui permet de créer des composants graphiques.</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;?xyl-stylesheet href="hoa://Library/Xyl/Css/Core.css"?&gt;
&lt;?xyl-use href="Comments.xyl"?&gt;

&lt;document xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;title&gt;Exemple&lt;/title&gt;

  &lt;section1&gt;
    &lt;title&gt;Commentaires&lt;/title&gt;

    &lt;comments bind="?data/to/comments" /&gt;
  &lt;/section1&gt;
&lt;/document&gt;</blockcode>
        <p>et notre fichier <code>Comments.xyl</code> :</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;definition xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;yield name="comments"&gt;
    &lt;yield bind="?comment"&gt;
      &lt;box&gt;
        &lt;image href="?avatar" /&gt;
        &lt;p&gt;&lt;value bind="?pseudo" /&gt; dit :&lt;/p&gt;
        &lt;blockquote bind="?message" /&gt;
      &lt;/box&gt;
    &lt;/yield&gt;
    &lt;hseparator /&gt;
  &lt;/yield&gt;
&lt;/definition&gt;</blockcode>
        <p>Mais <em>XYL</em> propose également un système d'<em>overlay</em>,
        <ie /> la capacité d'ajouter une partie d'une interface graphique dans
        une interface déjà existante. Ce qui est très pratique pour ajouter
        des modules sur un site de commerce par exemple.</p>
        <p><em>XYL</em> est un langage prometteur, assez différent ce qu'il se
        fait actuellement, mais qui a un avenir certain.</p>
      </section3>

      <section3 id="Le_respect_des_standards" for="main-toc">
        <title>Le respect des standards</title>

        <p>Hoa insiste énormément sur le respect des standards. En effet, les
        standards assurent une <strong>homogénéité</strong>, une
        <strong>interopérabilité</strong> et une <strong>pérennité</strong>.
        Des standards écrits par le <link href="http://w3.org">W3C</link> ne
        peuvent par exemple pas être ignorés. De même pour les RFC écrites par
        l'<link href="http://ietf.org/">IETF</link>, les normes
        <link href="http://iso.org/">ISO</link> ou encore les normes
        <link href="http://ieee.org/">IEEE</link> telle que la norme
        POSIX.</p>
        <p>Les normes ne manquent pas mais sont vitables. Leur respect est
        parfois difficile et compliqué. C'est pourquoi Hoa propose des
        bibliothèques respectueuses de ces standards. Ainsi, vous n'aurez pas
        à vous soucier de la syntaxe ou de la sémantique des données
        manipulées ou produites, vous êtes assurés quelles seront
        compréhensibles et exploitables par d'autres programmes.</p>
      </section3>
    </section2>

    <section2 id="Ensemble_de_bibliotheques_ou_framework" for="main-toc">
      <title>Ensemble de bibliothèques ou framework ?</title>

      <p>Avoir un ensemble de bibliothèques est pratique et utile pour
      développer ses propres outils, voire ses propres bibliothèques. En
      revanche, certaines contraintes rencontrées au quotidien nous obligent à
      travailler vite, ce qui implique d'avoir des processus automatisés.
      C'est en cela que les frameworks sont un atout de poids : ils
      automatisent des tâches.</p>
      <p>Du fait de la conception, de l'abstraction et de la modularité de
      Hoa, tout est surchargeable. Par exemple, lors de l'instanciation d'une
      bibliothèque, on utilisera ses paramètres déclarés dans le code.
      Seulement, si le fichier
      <code>hoa://Data/Etc/Configuration/.Cache/<em>Foobar</em>.php</code>
      existe, alors la bibliothèque sera configurée de manière transparente
      avec les paramètres contenus dans le dit fichier.</p>
      <p>Ce qu'on comprend, c'est que les bibliothèques seules fonctionnent de
      manière autonomes, mais que si on veut utiliser Hoa en tant que
      framework, de nouveaux mécanismes apparaissent de manière transparente.</p>
    </section2>

    <section2 id="Architecture" for="main-toc">
      <title>Architecture</title>

      <p>L'architecture de Hoa est très simple. On peut différencier deux
      parties : la partie framework (<code>Framework</code>) et la partie
      données (<code>Data</code>). La partie framework contient :</p>
      <ulist>
        <item><code>Core</code>, le noyau ;</item>
        <item><code>Library</code>, les bibliothèques standards (la famille
        <em>Hoa</em>) ;</item>
        <item><code>Module</code>, les bibliothèques utilisateurs (la famille
        <em>Hoathis</em>) ;</item>
        <item><code>Optional</code>, des bibliothèques additionnelles.</item>
      </ulist>
      <p>La partie données contient :</p>
      <ulist>
        <item><code>Bin</code>, des outils en ligne de commandes pour gérer
        votre programme ;</item>
        <item><code>Etc</code>, les fichiers de configurations, les locales
        etc. ;</item>
        <item><code>Lost+found</code>, les fichiers perdues (normalement,
        toujours vide) ;</item>
        <item><code>Module</code>, les bibliothèques utilisateurs réservées
        uniquement pour votre programme ;</item>
        <item><code>Optional</code>, des bibliothèques additionnelles
        réservées uniquement pour votre programme ;</item>
        <item><code>Temporary</code>, les fichiers temporaires ;</item>
        <item><code>Variable</code>, les fichiers caches, les bases de
        données, les logs, les tests etc.</item>
      </ulist>
      <p>Hoa est conçu selon le principe <em>un ensemble de bibliothèques pour
      plusieurs applications</em>, <ie /> on place le dossier
      <code>Framework</code> a un seul endroit et toutes les applications vont
      travailler dessus. Un programme est constitué de deux dossiers : le
      premier est maintenant connu, il s'agit de <code>Data</code>, le second
      est conventionnellement <code>Application</code>, mais ça peut être
      n'importe quoi d'autre. Ce couple de dossier s'appelle une
      <em>application</em> dans la terminologie Hoa. Notez que le dossier
      <code>Data</code> n'est pas obligatoire mais il permet, comme les
      frameworks le proposent, un cadre de développement propre et organisé.</p>
    </section2>
  </section1>

  <section1 id="Demarrage_rapide" for="main-toc">
    <title>Démarrage rapide</title>

    <p>La majorité des lectrices et lecteurs de ce manuel veulent utiliser le
    maximum de ce que Hoa propose, à savoir la combinaison ensemble de
    bibliothèque et framework. C'est pourquoi on va donner un exemple simple
    d'une petite application.</p>

    <section2 id="Installer_Hoa" for="main-toc">
      <title>Installer Hoa</title>

      <p>Il existe différente manière d'installer Hoa : soit à travers les
      archives, soit à travers
      <link href="http://mercurial.selenic.com/">Mercurial</link>. Ce dernier
      permet des mises à jour plus aisées, il est par conséquent conseillé.
      Ainsi :</p>
      <blockcode language="shell">$ mkdir -p ~/Development/Hoa/
$ cd !!$
$ hg clone http://hg.hoa-project.net/Central
$ cd Central</blockcode>
      <p>Nous y sommes : Hoa est installé. Toutefois, pensons à vérifier que PHP
      est bien installé également et que sa version est supérieure ou égale à
      5.3.0, alors :</p>
      <blockcode language="shell">$ which php
/usr/bin/php
$ php --version | grep -e "^PHP"
PHP 5.3.x (cli) (built: …)</blockcode>
      <p>Excellent ! Nous avons PHP et Hoa d'installés. Hoa est bien constitué
      de deux parties : <code>Framework</code> et <code>Data</code>,
      respectivement pour les bibliothèques et pour le complément de votre
      application. Dans un premier temps, nous allons les laisser au même niveau
      et nous verrons par la suite comment les séparer. Nous allons alors
      vérifier que la commande <code>hoa</code> fonctionne, elle peut être utile
      pour automatiser certaines tâches et pour visualiser certains concepts ;
      alors :</p>
      <blockcode language="shell">$ ./Data/Bin/hoa
interface de bienvenue</blockcode>
      <p>Comme la partie <code>Data</code> est destinée à votre application, il
      n'y a aucun problème à renommer cette commande ; ainsi :</p>
      <blockcode language="shell">$ sudo ln -s `pwd`/Data/Bin/hoa /usr/bin/myapp
Password:

$ myapp
interface de bienvenue</blockcode>
      <p>Notons que cette partie n'est pas obligatoire, mais elle permet un
      confort lorsqu'on manipule plusieurs applications.</p>
    </section2>
    <section2 id="Premiere_lignes_de_code" for="main-toc">
      <title>Première lignes de code</title>

      <p>Passons à des choses plus sérieuses : nous allons créer notre
      application. Pour nous simplifier les choses, nous allons la créer dans
      <code>Central</code> :</p>
      <blockcode language="shell">$ myapp application:start
Creating the skeleton of our application.
  * Create hoa://Application/Public.              [ok]
  * Create hoa://Application/Public/index.php.    [ok]
$ myapp tree Application
Application/
|-- Public/
|   |-- index.php
$ cd Application/Public
$ php index.php
Hello you! I'm Hoa and I'm installed :-).</blockcode>
      <p>Allons plus loin en écrivant un routeur et un contrôleur basique,
      <ie /> le routeur va capturer des requêtes, les analyser et le dispatcheur
      va les utiliser pour distribuer les actions. Pour commencer, nous n'allons
      faire qu'une seule règle dans le routeur, nommée <code>g</code>, qui se
      verra associer comme action une fonction qui se contente d'afficher
      <code>Hello …!</code> où <code>…</code> sera la requête. On modifie alors
      <code>index.php</code> :</p>
      <blockcode language="php">&lt;?php

require __DIR__ . '/../../Framework/Core/Core.php';

from('Hoa')
-> import('Controller.Dispatcher.Basic')
-> import('Controller.Router');

$router = new Hoa\Controller\Router();
$router->addRule('g', '(?&lt;all&gt;.*)', function ( $all ) {

    echo 'Hello ' . $all . '!' . "\n";
});

$dispatcher = new Hoa\Controller\Dispatcher\Basic();
$dispatcher->dispatch($router);</blockcode>
      <p>Testons notre application :</p>
      <blockcode language="shell">$ php index.php gordon
Hello gordon!</blockcode>
      <p>C'est déjà un excellent début. On comprend que l'on instancie un
      routeur auquel on ajoute une règle. Puis on instancie un contrôleur dit
      basique auquel on demande d'effectuer un dispatche en fonction du routeur
      précédent.</p>
      <p>On remarque que dans le motif de la règle, à savoir
      <code>(?&amp;amp;lt;all&amp;amp;gt;.*)</code>, la partie
      <code>?&amp;amp;lt;all&amp;amp;gt;</code> permet de nommer une capture,
      que l'on effectue avec des parenthèses. On remarque également que
      l'argument de notre fonction anonyme porte le même nom que notre capture.
      Ce mécanisme intuitif nous permet donc de récupérer les valeurs des
      captures de la règle sélectionnée par le routeur.</p>
      <p>Ajoutons une règle pour bien comprendre le mécanisme :</p>
      <blockcode language="php">$router
    ->addRule('h', 'p(?&lt;id&gt;\d+)-(?&lt;title&gt;.*)', function ( $id, $title ) {

        echo 'Picture #' . $id . ': ' . $title . '.' . "\n";
    })
    ->addRule('g', '(?&lt;all&gt;.*)', function ( $all ) {

        echo 'Hello ' . $all . '!' . "\n";
    });</blockcode>
      <p>Tout d'abord, nous remarquons que la règle a été ajoutée avant la
      première car, de toute évidence, notre règle <code>g</code> est plus générique
      et comprend tous les cas. L'ordre de déclarations des règles à un sens, il
      faut y prêter une attention toute particulière.</p>
      <p>Testons alors notre nouvelle application :</p>
      <blockcode language="shell">$ php index.php gordon
Hello gordon!
$ php index.php p42-foobar
Picture #42: foobar.</blockcode>
    </section2>

    <section2 id="Allons_un_peu_plus_loin" for="main-toc">
      <title>Allons un peu plus loin</title>

      <p>Notre application est très minimale, et si elle est appelée à grandir
      il nous faudra mieux la structurer. C'est pourquoi il existe le modèle de
      conception MVC qui permet de différencier la partie donnée, contrôle des
      données et vue. On va l'appliquer de manière minimale et incrémentale.</p>

      <section3 id="Vous_avez_dit_MVC" for="main-toc">
        <title>Vous avez dit MVC ?</title>

        <p>Commençons par créer un contrôleur, <ie /> la partie qui va
        contrôler les données, partie que l'on peut assimiler aux fonctions
        anonymes que l'on utilisait dans nos exemples précédents. Pour cela, on
        peut s'aider de notre commande <code>myapp</code> :</p>
        <blockcode language="shell">$ myapp controller:create index
Creating index controller.
  * Create hoa://Application/Controller.              [ok]
  * Create hoa://Application/Controller/Index.php.    [ok]
  * Create IndexController.                           [ok]
$ myapp tree hoa://Application
hoa://Application/
|-- Controller/
|   |-- Index.php
|-- Public/
|   |-- index.php</blockcode>
        <p>Éditons alors <code>Index.php</code> de cette façon :</p>
        <blockcode language="php">&lt;?php

class IndexController {

    public function IndexAction ( $all ) {

        echo 'Hello ' . $all . '!' . "\n";
    }

    public function PictureAction ( $id, $title ) {

        echo 'Picture #' . $id . ': ' . $title . '.' . "\n";
    }
}</blockcode>
        <p>Puis, modifions notre routeur en conséquence, soit
        <code>index.php</code> :</p>
        <blockcode language="php">$router = new Hoa\Controller\Router();
$router
    ->addRule('h', 'p(?&lt;id&gt;\d+)-(?&lt;title&gt;.*)', 'index', 'picture')
    ->addRule('g', '(?&lt;all&gt;.*)', 'index', 'index');
        </blockcode>
        <p>Testons notre application à nouveau :</p>
      <blockcode language="shell">$ php index.php gordon
Hello gordon!
$ php index.php p42-foobar
Picture #42: foobar.</blockcode>
        <p>Aucune différence au final, sauf que cette fois-ci nous n'avons plus
        de fonctions anonymes pour les contrôleurs et actions, mais des
        contrôleurs qui sont des classes et des actions qui sont des
        méthodes.</p>
      </section3>

      <section3 id="Du_terminal_au_navigateur" for="main-toc">
        <title>Du terminal au navigateur</title>

        <p>On va quitter le terminal pour le navigateur, ce sera plus
        confortable pour la suite de l'exercice, à savoir visualiser de
        l'HTML. Pour cela, on doit préciser au serveur que l'on utilise un
        moteur de réécriture afin que notre routeur fonctionne correctement, et
        on va par conséquent préciser au routeur que les adresses sont réécrites
        par le serveur.</p>
        <p>Si on utilise un serveur Apache, on devra écrire un fichier
        <code>.htaccess</code> dans notre dossier <code>Public</code> de cette
        façon :</p>
        <blockcode>RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php?$1</blockcode>
        <p>Et lorsque l'on instancie notre routeur, on doit passer le paramètre
        <code>rewrited</code> à <code>true</code>. On peut le faire de cette
        façon :</p>
        <blockcode language="php">$router = new Hoa\Controller\Router(array(
    'rewrited' => true
));</blockcode>
        <p>Ou de cette façon :</p>
        <blockcode language="php">$router = new Hoa\Controller\Router();
$router->setParameter('rewrited', true);</blockcode>
        <p>Ainsi, on peut vérifier que tout fonctionne toujours correctement :</p>
        <blockcode language="shell">$ curl http://localhost:8888/gordon
Hello gordon!
$ curl http://localhost:8888/p42-foobar
Picture #42: foobar.</blockcode>
        <p>Vous devriez en toute logique obtenir les mêmes résultats dans votre
        navigateur.</p>
      </section3>

      <section3 id="Decouverte_de_XYL" for="main-toc">
        <title>Découverte de XYL</title>

        <p>XYL signifie <em>XML Yielding Language</em> et est le langage
        d'interface graphique que propose Hoa. Ce langage est multi-sorties,
        multi-plateformes, orienté composants, productions et superpositions.
        Dans un premier temps, on va demander d'interpréter XYL comme étant de
        l'HTML et d'écrire le résultat fraîchement produit dans une requête HTTP
        en tant que réponse, <ie /> faire du Web traditionnel.</p>
        <p>Pour arriver à nos fins, on va modifier notre fichier
        <code>index.php</code> pour y ajouter de nouvelles importations :</p>
        <blockcode language="php">-> import('Xyl.~')
-> import('Xyl.Interpreter.Html.~')
-> import('File.Read')
-> import('Http.Response');</blockcode>
        <p>Et modifier notre dispatcheur en lui ajoutant en second paramètre une
        vue :</p>
        <blockcode language="php">$dispatcher->dispatch(
    $router,
    new Hoa\Xyl(
        new Hoa\File\Read('hoa://Application/View/Main.xyl'),
        new Hoa\Http\Response(),
        new Hoa\Xyl\Interpreter\Html()
    )
);</blockcode>
        <p>On fournit à XYL un fichier en entrée, une réponse HTTP en sortie et
        on lui demande d'interpréter l'entrée comme de l'HTML.
        Les choses deviennent intéressantes. On va commencer par écrire notre
        fichier <code>hoa://Application/View/Main.xyl</code> qui sera notre vue
        principale à laquelle va venir s'ajouter ou se greffer de nouvelles
        vues.</p>
        <p>Un fichier XYL peut-être de trois sortes : un document
        (<code>&amp;amp;lt;document&amp;amp;gt;</code>), des définitions
        (<code>&amp;amp;lt;definition&amp;amp;gt;</code>) ou des superpositions
        (<code>&amp;amp;lt;overlay&amp;amp;gt;</code>). Tout d'abord, on utilisera
        simplement un document et on verra par la suite les définitions ;
        ainsi :</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;document xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;title&gt;My application&lt;/title&gt;

  &lt;section1&gt;
    &lt;title bind="?hello" /&gt;

    &lt;page /&gt;
  &lt;/section1&gt;
&lt;/document&gt;</blockcode>
        <p>On remarque l'espace de nom
        <code>http://hoa-project.net/xyl/xylophone</code> qui est obligatoire
        pour interpréter du XYL. Ensuite, notre attention se portera sur
        l'attribut <code>bind</code> du composant
        <code>&amp;amp;lt;title&amp;amp;gt;</code>. Cet attribut constitue une
        des bases fondamentales de XYL car il permet de lier des données à un
        composant. On verra par la suite comment assigner des données et quel
        impact cela peut-il avoir lors du rendu (comprendre de l'interprétation)
        d'un document XYL.</p>
        <p><em>A l'instar</em> de la production de données, la création de
        composant, grâce à <code>&amp;amp;lt;yield&amp;amp;gt;</code>, est une
        des bases fondamentales de XYL. Ici, on utilise un composant que l'on
        crée qui s'appelle : <code>&amp;amp;lt;page&amp;amp;gt;</code> et sa
        définition changera selon la requête effectuée (comprendre selon le
        contexte).</p>
        <p>Il existe plusieurs manières d'écrire une définition. La plus
        triviale s'effectue dans le document lui-même, de cette façon :</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;document xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;title&gt;My application&lt;/title&gt;

  &lt;section1&gt;
    &lt;title bind="?hello" /&gt;

    &lt;yield name="page"&gt;
      &lt;p&gt;Hello world!&lt;/p&gt;
    &lt;/yield&gt;

    &lt;page /&gt;
  &lt;/section1&gt;
&lt;/document&gt;</blockcode>
        <p>Ainsi, le composant <code>&amp;amp;lt;page&amp;amp;gt;</code> sera
        remplacer par sa définition décrite par <code>&amp;amp;lt;yield
        name=page"&amp;amp;gt;</code>. Mais il est parfois préférable d'écrire
        les définitions de composants à l'extérieur de notre document (ce qui
        est très pratique pour obtenir des bibliothèques de composants). Une des
        manières de le faire est statiquement :</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;?xyl-use href="hoa://Application/View/Definitions.xyl"?&gt;

&lt;document xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;title&gt;My application&lt;/title&gt;

  &lt;section1&gt;
    &lt;title bind="?hello" /&gt;

    &lt;page /&gt;
  &lt;/section1&gt;
&lt;/document&gt;</blockcode>
        <p>Et dans <code>Definitions.xyl</code> :</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;definition xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;yield name="page"&gt;
    &lt;p&gt;Hello world!&lt;/p&gt;
  &lt;/yield&gt;
&lt;/definition&gt;</blockcode>
        <p>Toutefois, cela reste très statique, <em>a contrario</em> de
        dynamique. Cela implique que si on veut donner une autre définition à
        notre composant, on ne peut pas sauf en modifiant le document.
        C'est pourquoi, on est capable de spécifier à l'exécution quelle
        définition utilisée. On le verra dans notre contrôleur. Pour l'instant,
        on va se contenter d'écrire deux définitions différentes de notre
        composant <code>&amp;amp;lt;page&amp;amp;gt;</code> : une pour notre
        règle de routeur <code>g</code> (« toutes les requêtes ») et une pour la
        règle <code>h</code> (« <code>p42-foobar</code> »). Ainsi, on écrira
        deux fichiers. Le premier, <code>Index.xyl</code> :</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;definition xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;yield name="page"&gt;
    &lt;p bind="?intro" /&gt;
  &lt;/yield&gt;
&lt;/definition&gt;</blockcode>
        <p>Le second, <code>Picture.xyl</code> :</p>
        <blockcode language="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;definition xmlns="http://hoa-project.net/xyl/xylophone"&gt;
  &lt;yield name="page"&gt;
    &lt;ulist&gt;
      &lt;item bind="?picture"&gt;
        #&lt;value bind="?id" /&gt; — &lt;value bind="?title" /&gt;.
      &lt;/item&gt;
    &lt;/ulist&gt;
  &lt;/yield&gt;
&lt;/definition&gt;</blockcode>
        <p>On avance, c'est très bien. Il ne nous reste qu'à modifier notre
        contrôleur pour définir des données et afficher la vue. Pour cela, les
        actions des contrôleurs ont besoin de récupérer les données, la vue etc.
        La manière la plus répandue avec le dispatcheur basique est d'utiliser
        <code>$_this</code> en tant qu'argument de nos actions. S'il est
        présent, alors on lui donnera un objet de type
        <code>Hoa\Controller\Application</code> qui contient des informations
        utiles à notre application, comme la vue et ses données, le routeur ou
        encore le dispatcheur lui-même. Ainsi :</p>
        <blockcode language="php">&lt;?php
        
class IndexController {
  
    public function IndexAction ( $all, Hoa\Controller\Application $_this ) {

        $_this->data->hello = 'Hello ' . $all . '!';
        $_this->data->intro = 'This is a short introduction!';

        $_this->view->addUse('hoa://Application/View/Index.xyl');
        $_this->view->render();
    }
    
    …</blockcode>
        <p>On dit : on assigne deux données, <code>hello</code> et
        <code>intro</code>, on va utiliser dynamiquement les définitions
        contenus dans <code>hoa://Application/View/Index.xyl</code>, puis on va
        demander un rendu. Un rendu va peindre notre document dans la sortie de
        XYL. Rappelez-vous, c'est une réponse HTTP.</p>
        <p>Enfin, on édite également notre seconde action :</p>
        <blockcode language="php">…

    public function PictureAction ( $id, $title,
                                    Hoa\Controller\Application $_this ) {

        $_this->data->hello             = 'Hello picture!';
        $_this->data->picture[0]->id    = $id;
        $_this->data->picture[0]->title = $title;

        $_this->view->addUse('hoa://Application/View/Picture.xyl');
        $_this->view->render();
    }
}</blockcode>
        <p>On détaillera plus tard la manipulation des données.</p>
        <p>On va se contenter pour l'instant de tester notre page dans notre
        navigateur et on remarque tout fonctionne bien ! Le liage de données
        fonctionne, tout comme la définition dynamique de composant ! En effet,
        aller sur la page <code>http://localhost:8888/gordon</code> ou
        <code>http://localhost:8888/p42-foobar</code> ne donnera pas le même
        résultat, c'est bien la preuve que la définition du composant
        <code>&amp;amp;lt;page&amp;amp;gt;</code> est différente selon la
        requête. De plus, on remarquera que <code>Main.xyl</code> se comporte
        comme une vue frontale, <ie /> une vue autour de nos pages, presque
        toujours visibles. C'est une des nombreuses conséquences des définitions
        dynamiques.</p>
        <p>Enfin, pour mieux saisir la puissance du mécanisme de liage de
        données, on va émuler plusieurs données pour notre action
        <code>picture</code>. Ainsi, on va imaginer que les données proviennent
        d'une base de données, sous forme d'un tableau associatif. On aura :</p>
        <blockcode language="php">…

    public function PictureAction ( $id, $title,
                                    Hoa\Controller\Application $_this ) {

        $_this->data->hello   = 'Hello picture!';
        $_this->data->picture = $this->dataFromModel($id, $title);

        $_this->view->addUse('hoa://Application/View/Picture.xyl');
        $_this->view->render();
    }

    protected function dataFromModel ( $id, $title ) {

        $out = array();

        for($i = 0; $i &lt; $id; ++$i)
            $out[$i] = array(
                'id'    => $i,
                'title' => md5($i . $title)
            );

        return $out;
    }
}</blockcode>
        <p>Si vous affichez <code>http://localhost:8888/p7-foobar</code>, vous
        verrez que la liste va contenir plusieurs éléments.</p>
        <p>Cela est dû à ces trois lignes de XYL :</p>
        <blockcode language="xml">&lt;item bind="?picture"&gt;
  #&lt;value bind="?id" /&gt; — &lt;value bind="?title" /&gt;.
&lt;/item&gt;</blockcode>
        <p>On dit : on se lie à la branche de données <code>picture</code>, puis
        on affiche les feuilles <code>id</code> et <code>title</code>. S'il
        existe plusieurs branches, alors, lors du rendu, on affichera toutes les
        branches <code>picture</code>. On comprend alors que le mécanisme de
        liage fonctionne sur un arbre à 1 ou <em>n</em> branches, <ie />
        indifférement si c'est une donnée scalaire (comprendre plate, à 1
        dimension) ou non-scalaire (comprendre structurelle, à <em>n</em>
        dimensions). Autrement dit, les boucles sont implicites dans le
        mécanisme de liage. Le travail doit être préparé en amont dans les
        actions lors de l'assignation des données, mais pas dans la vue.</p>
        <p>Ce mécanisme est très puissant et plutôt intuitif. On peut faire bien
        plus de choses avec, mais ce n'est qu'un démarrage rapide.</p>
      </section3>
    </section2>

    <section2 id="Conclusion" for="main-toc">
      <title>Conclusion</title>

      <p>Hop :-).</p>
    </section2>
  </section1>
</document>
