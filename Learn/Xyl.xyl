<?xml version="1.0" encoding="utf-8"?>
<?xyl-use href="../Definitions.xyl"?>

<definition xmlns="http://hoa-project.net/xyl/xylophone">
<yield name="chapter">


  <h1 id="Model">Manuel d'apprentissage<title_break />XYL</h1>

  <ul class="prev_next">
    <li><a href="@ll:chapter=Model"><previous_chapter /> Modèle de
        données</a></li>
  </ul>

  <p>Le système d'interface graphique permet de déclarer des
  <strong>vues</strong>. Il peut se cantonner à un simple affichage de données
  de manière ordonnée ou alors offrir bien plus de services, notamment sur la
  <strong>maintenance</strong>. Dans ce chapitre, nous allons présenter
  la bibliothèque <code>Hoa\View</code> et la bibliothèque
  <code>Hoa\Xyl</code>.</p>

  <h2 id="Table_des_matieres" for="menu-toc">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Introduction" for="main-toc menu-toc">Introduction</h2>

  <p>D'une manière générale, le mécanisme d'un système de vue est le suivant : à
  partir de <strong>données</strong> sous différentes formes, nous allons créer
  une <strong>vues</strong>, l'agencer, la modifer, la mélanger aux données,
  puis en faire un rendu. Un <strong>rendu</strong> est comparable à peindre
  notre vue, <ie /> nous voulons en avoir un résultat partiel ou total. Ce
  résultat est affiché ou stocké, ce qui est dans tous les cas comparables à
  l'envoyer sur un flux. Enfin, un besoin annexe mais indispensable aux vues est
  la présence d'un <strong>routeur</strong>. En effet, les vues ont besoin de
  connaître les accès aux différentes ressources voire de localiser d'autres
  vues.</p>
  <p>Les besoins en terme d'interface graphique sont <strong>nombreux</strong>
  et très <strong>variés</strong> les uns des autres selon les contextes
  d'utilisation. C'est pourquoi il existe plusieurs outils. Dans un souci
  d'ouverture et d'uniformité, la bibliothèque <code>Hoa\View</code> ne définit
  qu'une seule interface : <code>Hoa\View\Viewable</code> qui définit quatre
  méthodes :</p>
  <ul>
    <li><code>getOutputStream</code> pour connaître le flux sur lequel la vue va
    être rendue ;</li>
    <li><code>getData</code> pour obtenir les données de la vue ;</li>
    <li><code>render</code> pour effectuer un rendu de la vue ;</li>
    <li><code>getRouter</code> pour obtenir le routeur associé à la vue.</li>
  </ul>
  <p>Cette interface est suffisante pour représenter la majorité des systèmes
  d'interface graphique. Ainsi, il est envisageable de développer votre propre
  système ou de brancher un système existant au reste des bibliothèques de Hoa.
  Toutefois, pour plus de confort, un système d'interface graphique est proposé
  dans Hoa : XYL.</p>
  <p><strong>XYL</strong> signifie <em>XML Yielding Language</em>. C'est un
  langage XML qui se base sur la théorie des composants et mélange des
  paradigmes de plusieurs langages d'interface graphique ou de manipulation de
  données tels que <a href="http://w3.org/TR/html5">HTML</a>,
  <a href="https://developer.mozilla.org/en/XUL">XUL</a>,
  <a href="http://w3.org/TR/xslt20">XSLT</a>,
  <a href="http://w3.org/TR/xpath20">XPath</a>,
  <a href="http://www.w3.org/TR/CSS">CSS</a> etc.</p>

  <h3 id="Composants_et_bibliotheques_graphiques" for="main-toc">Composants et
  bibliothèques graphiques</h3>

  <p>XYL permet la création de <strong>composants</strong> graphiques
  <strong>exécutables</strong> et <strong>réutilisables</strong>. Ces composants
  peuvent être <strong>assemblés</strong> entre eux afin de construire des
  composants plus importants. Il est possible d'avoir des
  <strong>bibliothèques</strong> de composants graphiques centralisées,
  facilement partageables et maintenables. Une bibliothèque de composants par
  défaut existe et reprend toutes les balises d'HTML en y ajoutant les
  particularités de XYL. Nous parlons alors du vocabulaire de XYL, ou du nommage
  des composants. Un avantage non négligeable d'avoir repris le vocabulaire
  d'HTML est que l'<strong>apprentissage</strong> de XYL est quasiment nul,
  sachant que les particularités proposées sont <strong>simples</strong> mais
  puissantes.</p>

  <h3 id="Yielding" for="main-toc"><em>Yielding</em></h3>

  <p>Le « Y » de XYL signifie <em>yielding</em>, <ie /> que XYL est un langage
  de production. Le mécanisme de <em>yielding</em> <strong>propre à XYL</strong>
  est bien adapté aux problématiques des systèmes d'interface graphique. Par
  exemple, lors de la création d'un composant graphique, ce dernier ne connait
  pas la quantité de données qu'il va devoir produire ; il ne connaît que la
  forme (nous détaillerons cette partie plus loin). Il ne connaît pas non plus
  le contexte dans lequel il va être utilisé et encore moins avec quels
  composants il sera associé.</p>
  <p>Cette approche facilite l'<strong>écriture</strong> de composants
  graphiques, le <strong>partage</strong> de tous ces composants entre plusieurs
  projets et leurs <strong>maintenaces</strong>.</p>

  <h3 id="Multi-plateformes_et_multi-sorties" for="main-toc">Multi-plateformes
  et multi-sorties</h3>

  <p>Nous avons dit que XYL était exécutables. Mieux encore, c'est un langage
  <strong>interprété</strong> : en fonction de la plateforme ou du type de
  sortie (applications Web, applications de bureau, de tablette, de téléphone,
  de télévision, un terminal, un
  <a href="https://www.adobe.com/devnet/pdf/pdf_reference_archive.html">PDF</a>
  etc.), nous allons choisir un interpréteur et l'exécuter sur nos documents
  XYL. Le résultat sera normalement celui attendu.</p>
  <p>Cela offre des perspectives intéressantes pour PHP à savoir que nous
  pourrons le placer sur d'autres appareils et machines que des serveurs.</p>

  <h2 id="Document" for="main-toc menu-toc">Document</h2>

  <p>Pour introduire XYL, nous allons commencer par créer un document à l'aide
  du <strong>composant racine</strong> <code>document</code> dans le fichier
  <code>Main.xyl</code>. Tous les documents ou composants XYL travaillent sur
  l'<strong>espace de nom XML</strong>
  <code>http://hoa-project.net/xyl/xylophone</code> (attention à la casse). À ce
  document, nous allons définir un titre grâce au composant <code>title</code>,
  et enfin nous allons ajouter un paragraphe avec une liste non-ordonnée grâce
  aux composants <code>p</code>, <code>ul</code> et <code>li</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;p>This is my first XYL document! XYL is:&amp;lt;/p>
  &amp;lt;ul>
    &amp;lt;li>easy to learn;&amp;lt;/li>
    &amp;lt;li>simple;&amp;lt;/li>
    &amp;lt;li>powerful.&amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Nous allons maintenant interpréter ce document.</p>

  <h3 id="Interpretation" for="main-toc">Interprétation</h3>

  <p>Pour interpréter XYL, nous avons besoin de la classe <code>Hoa\Xyl</code>
  qui va préparer nos documents ainsi que nos données, et lancer le rendu de
  notre interprétation. XYL a besoin au minimum de :</p>
  <ul>
    <li>un flux d'entrée, pour lire le document XYL ;</li>
    <li>un flux de sortie, pour écrire le rendu de l'interprétation ;</li>
    <li>un interpréteur, représenté par la classe abstraite
    <code>Hoa\Xyl\Interpreter</code>.</li>
  </ul>
  <p>Nous allons commencer avec l'interpréteur HTML qui est le plus simple à
  déployer, représenté par la classe <code>Hoa\Xyl\Interpreter\Html</code>.
  Notre flux de sortie sera représenté par la classe
  <code>Hoa\Http\Response</code>. Ainsi, créons le fichier
  <code>index.php</code> :</p>
  <pre><code language="php">from('Hoa')
-> import('File.Read')
-> import('Http.Response')
-> import('Xyl.~')
-> import('Xyl.Interpreter.Html.~');

$xyl = new Hoa\Xyl(
    new Hoa\File\Read('Main.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html()
);
$xyl->render();</code></pre>
  <p>Il suffit maintenant d'exécuter ce fichier PHP pour observer le
  résultat :</p>
  <pre><code language="shell">$ php index.php</code></pre>
  <p>Ou depuis un navigateur (à l'aide de Bhoa par exemple) :</p>
  <pre><code language="shell">$ myapp bhoa --root .</code></pre>
  <p>puis en ouvrant l'URL
  <a href="http://localhost:8888"><code>localhost:8888</code></a>.</p>
  <p>Nous vous conseillons d'essayer de modifier ce document XYL comme si
  c'était de l'HTML pour vous rendre compte que le vocabulaire est le même (par
  exemple en ajoutant des identifiants, des classes, d'autres composants/balises
  etc.)</p>

  <h3 id="Feuilles_de_style" for="main-toc">Feuilles de style</h3>

  <p>L'objectif de XYL est de définir la <strong>structure</strong> et une
  partie du <strong>comportement</strong> d'un document mais jamais il ne
  définira son style. Ce travail doit être réalisé par un autre langage, de
  préférence <a href="http://www.w3.org/TR/CSS">CSS</a> mais ce n'est pas
  obligatoire, le choix étant laissé à l'utilisateur.</p>
  <p>Pour déclarer une feuille de style, nous utilisons la
  <a href="http://w3.org/TR/xml11/#sec-pi"><em>processing-instruction</em></a>
  <code>&amp;amp;lt?xyl-stylesheet?></code> en tête de n'importe quels documents
  XYL avec son attribut <code>href</code> pour préciser l'emplacement de notre
  feuille de style. Nous parlons d'une <strong>déclaration statique</strong>.
  Ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="UI.css"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  …</code></pre>
  <p>Et notre fichier <code>UI.css</code> :</p>
  <pre><code language="css">body {
    color: red
}</code></pre>
  <p>Maintenant, réouvrons
  <a href="http://localhost:8888"><code>localhost:8888</code></a> et nous
  observons que notre document a changé de style.</p>
  <p>Nous pouvons dynamiquement déclarer une feuille de style en utilisant la
  méthode <code>addStylesheet</code> de la classe <code>Hoa\Xyl</code>. Ainsi,
  le code suivant produira le même résultat :</p>
  <pre><code language="php">$xyl = new Hoa\Xyl(
    new Hoa\File\Read('Main.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html()
);
$xyl->addStylesheet('UI.css');
$xyl->render();</code></pre>

  <h2 id="Overlay" for="main-toc menu-toc"><em>Overlay</em></h2>

  <p>Les <strong><em>overlays</em></strong> sont un ou plusieurs composants que
  nous voulons <strong>insérer</strong> dans un document. Par exemple, imaginons
  une application qui présente un contenu et une colone sur le côté contenant
  plusieurs extensions que l'utilisateur de l'application peut installer comme
  il le souhaite.  Chaque extension est définie comme un <em>overlay</em> qui ne
  sait pas comment est construit le document principal, mais il connaît
  l'identifiant de la colonne contenant les extensions. Cette information est
  amplement suffisante !  Ainsi, lorsque l'extension va s'installer,
  l'application n'aura qu'à déclarer un nouvel <em>overlay</em> dans le document
  et il bénéficiera de <strong>toutes les ressources</strong> du document. En
  plus de préciser où s'accrocher par rapport à un composant, il peut préciser
  sa position dans ce composant.</p>
  <p><em>À l'instar</em> d'une déclaration de feuille de style, une déclaration
  d'<em>overlay</em> se fait avec une <em>processing-instruction</em> :
  <code>&amp;amp;lt;?xyl-overlay?></code> en tête de n'importe quels documents
  XYL et avec son attribut <code>href</code> pour préciser l'emplacement de
  notre <em>overlay</em>. De même, pour une déclaration dynamique, nous avons la
  méthode <code>addOverlay</code> sur la classe <code>Hoa\Xyl</code>. Ainsi,
  nous déclarons l'<em>overlay</em> contenu dans le fichier
  <code>Extension.xyl</code> à notre document auquel nous avons ajouté un
  composant portant l'identifiant <code>extensions</code> et accueillant déjà
  une extension :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="UI.css"?>
&amp;lt;?xyl-overlay href="Extension.xyl"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;article>
    &amp;lt;h1>My blog&amp;lt;/h1>
    &amp;lt;p>This is my blog.&amp;lt;/p>
  &amp;lt;/article>

  &amp;lt;aside id="extensions">
    &amp;lt;h1>Extensions&amp;lt;/h1>
    &amp;lt;div id="bar">
      &amp;lt;h2>Bar&amp;lt;/h2>
      &amp;lt;p>Awesome bar.&amp;lt;/p>
    &amp;lt;/div>
  &amp;lt;/aside>
&amp;lt;/document></code></pre>
  <p>Nous avons précisé que tous les documents XYL peuvent déclarer des
  <em>overlays</em>, ce qui signifie qu'un <em>overlay</em> peut utiliser
  d'autres <em>overlays</em> et ainsi de suite, mais tous s'appliqueront sur le
  document final.</p>

  <h3 id="Composition_d-un_overlay" for="main-toc">Composition d'un
  <em>overlay</em></h3>

  <p>Étudions maintenant la <strong>composition</strong> d'un <em>overlay</em>.
  Tout d'abord, nous utilisons le <strong>composant racine</strong>
  <code>overlay</code>. Chaque fils de ce composant racine représente un
  <strong>composant de référence</strong> qui indique sur quel composant nous
  voulons nous <strong>accrocher</strong>. Chaque fils d'un composant de
  référence représente un <strong>composant à insérer</strong>.</p>
  <pre><code language="xml">&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;reference_component>
    &amp;lt;component_to_insert>…&amp;lt;/component_to_insert>
    &amp;lt;component_to_insert>…&amp;lt;/component_to_insert>
  &amp;lt;/reference_component>

  &amp;lt;reference_component>
    …
  &amp;lt;/reference_component>
&amp;lt;/overlay></code></pre>
  <p>Le composant de référence a besoin d'un <strong>identifiant</strong> pour
  correctement créer une référence vers le composant dans lequel il va insérer
  des nouveaux composants. Tous ses nouveaux composants seront insérés après
  les composants déjà existants.</p>
  <p>Ajoutons une nouvelle extension dans notre colonne en écrivant dans notre
  fichier <code>Extension.xyl</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extension">
    &amp;lt;div id="foo">
      &amp;lt;h2>Foo&amp;lt;/h2>
      &amp;lt;p>Awesome foo.&amp;lt;/p>
    &amp;lt;/div>
  &amp;lt;/aside>
&amp;lt;/overlay></code></pre>
  <p>Réinterprétons notre document principal et notre nouvelle extension est
  bien présente dans notre colonne ! Seulement, nous aurions aimé placer cette
  extension en tête de colonne et non pas à la suite des extensions déjà
  présentes.</p>

  <h3 id="Positionner_des_overlays" for="main-toc">Positionner des
  <em>overlays</em></h3>

  <p>Chaque composant à insérer possède l'attribut <code>position</code> qui
  permet de <strong>positionner</strong> notre <em>overlay</em> parmi les
  composants qui vont l'accueillir. Les valeurs sont constituées des expressions
  suivantes :</p>
  <ul>
    <li>un <strong>index</strong> supérieur ou égal à zéro (<code>0</code>,
    <code>1</code>, …, <code><em>n</em></code>) ;</li>
    <li>une <a href="http://w3.org/TR/xpath20/#id-arithmetic"><strong>opération</strong>
    arithmétique XPath</a>, soit : l'addition (<code>+</code>, unaire ou
    binaire), la soustraction (<code>-</code>, unaire ou binaire), la
    multiplication (<code>*</code>), la division (<code>div</code>), la division
    entière (<code>idiv</code>) et le modulo (<code>mod</code>) ;</li>
    <li>un index <strong>dynamique</strong> :
    <code>element(#<em>anId</em>)</code>, pour connaître la position d'un
    élément déjà existant, ou <code>last()</code>.</li>
  </ul>
  <p>Prenons quelques exemples concrets pour bien comprendre. Pour positionner
  un <em>overlay</em> :</p>
  <ul>
    <li>en première position : <code>0</code> ;</li>
    <li>en seconde position : <code>1</code> (nous devrions comprendre que
    l'insertion se fait à <strong>gauche</strong>) ;</li>
    <li>en dernière position : <code>last()</code> ;</li>
    <li>en avant-dernière position : <code>last() - 1</code> ;</li>
    <li>après un composant portant l'identifiant <code>baz</code> :
    <code>element(#baz)</code> ;</li>
    <li>avant un composant portant l'identifiant <code>baz</code> :
    <code>element(#baz) - 1</code> ;</li>
    <li>de manière non-logique : <code>last() - 2 * element(#qux) mod
    3</code> ;</li>
    <li>etc.</li>
  </ul>
  <p>Attention : l'ordre d'insertion des composants va influer sur leurs
  positions. Toutes les expressions de position sont évaluées au dernier moment,
  soit juste avant l'insertion. Une position négative sera réduite à
  <code>0</code>, une position trop grande sera réduite à <code>last()</code> et
  une position non-entière sera tronquée à sa partie entière.</p>
  <p>Ainsi pour positionner notre nouvelle extension <code>foo</code> non pas en
  dernière position mais en première position, nous aurons la position
  <code>1</code> (utiliser la position <code>0</code> la placerait avant le
  titre de notre colonne) :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extension">
    &amp;lt;div id="foo" position="1">
      &amp;lt;h2>Foo&amp;lt;/h2>
      &amp;lt;p>Awesome foo.&amp;lt;/p>
    &amp;lt;/div>
  &amp;lt;/aside>
&amp;lt;/overlay></code></pre>
  <p>En complément, nous voulons ajouter un séparateur entre nos deux extensions
  grâce au composant <code>hr</code>. Nous avons donc un second composant à
  insérer et nous le positionnerons après notre composant <code>foo</code> ;
  ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extension">
    &amp;lt;div id="foo" position="1">
      &amp;lt;h2>Foo&amp;lt;/h2>
      &amp;lt;p>Awesome foo.&amp;lt;/p>
    &amp;lt;/div>

    &amp;lt;hr position="element(#foo)" />
  &amp;lt;/aside>
&amp;lt;/overlay></code></pre>
  <p>Si la position de notre nouvelle extension est modifiée, son séparateur
  sera toujours après elle sans <strong>ne rien changer</strong>.</p>

  <h3 id="Overlays_et_feuilles_de_style" for="main-toc"><em>Overlays</em> et
  feuilles de style</h3>

  <p>Les <em>overlays</em> peuvent également déclarer des feuilles de style
  grâce aux mécanismes vus précédemment. Ainsi, nous pouvons imaginer
  avoir :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="Extension.css"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extension">
    &amp;lt;div id="foo" position="1">
      …</code></pre>
  <p>Avec notre fichier <code>Extension.css</code> qui contiendrait :</p>
  <pre><code language="css">#foo {
    color: green
}</code></pre>
  <p>Après réinterprétation de notre document, le texte de notre extension aura
  un style différent. Ce mécanisme est intéressant si des extensions veulent
  <strong>embarquer</strong> leurs propres styles (ou d'autres ressources).</p>

  <h3 id="Un_peu_plus_loin_avec_les_overlays" for="main-toc">Un peu plus loin
  avec les <em>overlays</em></h3>

  <p>Un composant de référence est capable de <strong>modifier</strong> le
  composant dans lequel il va insérer de nouveaux composants : il peut lui
  ajouter ou modifier des attributs (mais pas en supprimer). Par exemple, si
  nous voulons ajouter un attribut <code>class</code> à notre colonne, nous
  ferons :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;overlay xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;aside id="extension" class="baz">
    &amp;lt;div id="foo" position="1">
      …</code></pre>
  <p>Selon le type d'attribut, le comportement s'adaptera. Dans le cas de
  l'attribut <code>class</code> (qui est de type liste), les nouvelles classes
  de style seront ajoutées aux existantes, alors que pour d'autres attributs, la
  valeur sera peut-être simplement remplacée.</p>

  <h2 id="Binding_et_yielding" for="main-toc menu-toc"><em>Binding</em> et
  <em>yielding</em></h2>

  <p>Le mécanisme de <strong>liage</strong> (ou
  <strong><em>binding</em></strong>) des données à notre vue est simple à
  comprendre et à utiliser si nous comprenons bien la <strong>forme</strong> de
  nos données.</p>

  <h3 id="Arbres_et_forets_de_donnees" for="main-toc">Arbres et forêts de
  données</h3>

  <p>XYL manipule des données qui ont la forme d'<strong>arbres</strong>. Pour
  simplifier la construction et manipulation de ces arbres (et aussi pour des
  raisons de performance), XYL utilise la classe <code>Hoa\Core\Data</code>.
  Cette classe est hautement dynamique : tout se déclare à la volée (attributs,
  indexes de tableaux etc.). Initialement, elle permet de manipuler des données
  <strong>polymorphiques</strong> ; dans le cas de XYL nous voulons l'utiliser
  uniquement comme un ensemble d'arbres, soit une <strong>forêt</strong>.</p>
  <p>Pour débuter avec les données, nous avons besoin de définir la forme de
  notre arbre pour <strong>un seul</strong> exemplaire. Imaginons par exemple un
  arbre <code>article</code> représentant un article et comportant les données
  suivantes :</p>
  <ul>
    <li>un identifiant <code>id</code> ;</li>
    <li>un titre <code>title</code> ;</li>
    <li>un auteur <code>author</code>.</li>
  </ul>
  <p>Avec une instance de <code>Hoa\Core\Data</code> que nous récupérons avec la
  méthode <code>getData</code> de <code>Hoa\Xyl</code>, nous avons :</p>
  <pre><code language="php">$xyl  = new Hoa\Xyl(…);
$data = $xyl->getData();

$data->article->id     = 0;
$data->article->title  = 'Foobar';
$data->article->author = 'G. Freeman';

$xyl->render();</code></pre>
  <p>Essayons de <strong>lier</strong> ces données grâce à l'attribut
  <code>bind</code> qui se trouve sur <strong>tous</strong> les composants
  XYL. La syntaxe d'un liage est <code>?[p[ath]:]<em>aTreeName</em></code>. Ainsi :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article">
      #&amp;lt;value bind="?id" /> &amp;lt;cite bind="?title" /> — &amp;lt;em bind="?author" />
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Nous voyons que le composant <code>li</code> se <strong>lie</strong> à
  l'arbre <code>article</code>, puis de même pour chacun de ses sous-arbres (ici
  des feuilles), respectivement <code>id</code>, <code>title</code> et
  <code>author</code>. Nous découvrons en même temps le composant
  <code>value</code> qui sert à afficher une valeur verbatim. Nous déduisons
  alors que faire <code language="xml">&amp;lt;cite bind="?title" /></code> est
  strictement équivalent à faire <code language="xml">&amp;lt;cite>&amp;lt;value
  bind="?title" />&amp;lt;/cite></code>.</p>
  <p>Si nous interprétons notre document, nous verrons bien les données
  apparaître.</p>
  <p>Maintenant que nous avons notre arbre, nous allons créer une
  <strong>forêt</strong>. Il faut savoir que dans le monde de XYL, tous les
  arbres de la même espèce sont strictement identiques à part la couleur de
  leurs feuilles, <ie /> les données finales, mais la forme des branches, et
  donc de l'arbre, est toujours <strong>identique</strong>. C'est pourquoi si
  nous créons un nouvel arbre <code>article</code>, il aura la même forme que
  celui que nous venons de créer. Nous accédons aux différents arbres grâce à un
  index comme pour un tableau ; ainsi :</p>
  <pre><code language="php">$data->article[0]->id     = 0;
$data->article[0]->title  = 'Foobar';
$data->article[0]->author = 'G. Freeman';

$data->article[1]->id     = 1;
$data->article[1]->title  = 'Bazqux';
$data->article[1]->author = 'A. Vance';</code></pre>
  <p>Sans modifier notre fichier XYL, nous allons le réinterpréter. Nous voyons
  que notre forêt d'arbres <code>article</code> est <strong>itérée</strong>
  correctement.</p>
  <p>Nous aimerions maintenant que chaque article puisse avoir plusieurs
  auteurs, nous allons alors créer un nouveau sous-arbre <code>name</code> sous
  le sous-arbre <code>author</code> :</p>
  <pre><code language="php">$data->article[0]->id                 = 0;
$data->article[0]->title           = 'Foobar';
$data->article[0]->author->name[0] = 'G. Freeman';
$data->article[0]->author->name[1] = 'G-Man';

$data->article[1]->id              = 1;
$data->article[1]->title           = 'Bazqux';
$data->article[1]->author->name    = 'A. Vance';</code></pre>
  <p>Nous devons modifier notre document XYL pour qu'il prenne en considérations
  ce nouveau sous-arbre :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article">
      #&amp;lt;value bind="?id" /> &amp;lt;cite bind="?title" />
      &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Les auteurs apparaissent comme attendus.</p>
  <p>Chaque composant qui fait un liage utilise un nouveau sous-arbre sur lequel
  ses sous-composants vont travailler.</p>
  <p>Cette forme de données peut paraître étrange au début mais elle s'adapte
  très bien aux outils d'<strong>extraction</strong> de données (comme les bases
  de données).</p>

  <h3 id="Inner-binding" for="main-toc"><em>Inner-binding</em></h3>

  <p>Nous avons vu l'attribut <code>bind</code> qui permet de lier le
  <strong>contenu</strong> d'un composant avec des données, mais nous pouvons
  également lier le contenu d'un <strong>attribut</strong> avec des données. Ce
  mécanisme s'appelle le <strong>liage-interne</strong> (ou
  <strong><em>inner-binding</em></strong>). Sa syntaxe est la même que pour un
  liage normal sauf que nous y ajoutons des parenthèses, soit :
  <code>(?[p[ath]:]<em>aTreeName</em>)</code>. Comme tous les composants sont
  liables, <strong>tous</strong> les attributs de tous les composants le sont
  également.  Ainsi, nous pouvons modifier notre document existant en
  déplacement la donnée <code>id</code> dans un attribut :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article" id="art_(?id)">
      &amp;lt;cite bind="?title" />
      &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>

  <h3 id="Donnees_symboliques_et_definition_de_composants"
  for="main-toc">Données symboliques et définition de composants</h3>

  <p>Maintenant que nous connaissons la forme des données et le mécanisme de
  liage (verbatim ou interne), nous allons nous intéresser à la création de
  composants graphiques qui est une finalité de XYL. Les données sont découpées
  uniformément et sont dites <strong>isolées</strong> et <strong>libres de
  contexte</strong>, ou plus simplement nous parlons de <strong>données
  symboliques</strong>.</p>
  <p>Un nouveau composant qui est souvent utile dans XYL est <code>yield</code>.
  Ce composant peut avoir trois fonctions :</p>
  <ul>
    <li>permettre de positionner un liage particulier, grâce à l'attribut
    <code>bind</code>, déjà bien connu ;</li>
    <li>créer un composant, grâce à l'attribut <code>name</code> ;</li>
    <li>créer un composant dynamique, grâce à l'attribut
    <code>select</code>.</li>
  </ul>
  <p>En premier lieu, <code>yield</code> ne fera aucun rendu de lui-même mais
  uniquement de ses enfants s'ils existent ou alors de son liage. Ainsi, la
  modification suivante du document remplacera notre liste d'auteurs avec les
  composants <code>ul</code> et <code>li</code> par simplement <code>em</code>
  (<code>yield</code> n'apparaîtra pas) :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;ul>
    &amp;lt;li bind="?article" id="art_(?id)">
      &amp;lt;cite bind="?title" /> — 
      &amp;lt;yield bind="?author">
        &amp;lt;em bind="?name" />
      &amp;lt;/yield>
    &amp;lt;/li>
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Ensuite, si nous utilisons un <strong>composant nommé</strong>,
  c'est à dire un composant <code>yield</code> avec l'attribut
  <code>name</code>, alors nous créons un nouveau composant que nous pouvons
  réutiliser où nous voulons et autant de fois que nous le désirons. Par
  exemple, nous allons créer un composant nommé <code>author_article</code>,
  puis l'utiliser :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 id="art_(?id)">&amp;lt;value bind="?title" />&amp;lt;/h1>
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>

  &amp;lt;author_article bind="?article" />
&amp;lt;/document></code></pre>
  <p>Nous <strong>lions</strong> les données au composant
  <code>author_article</code> toujours grâce à l'attribut <code>bind</code>.
  Utiliser un attribut <code>bind</code> sur un composant <code>yield</code> qui
  porte un attribut <code>name</code> n'aura <strong>aucun</strong> effet mais
  peut servir de <em>memorandum</em> !</p>
  <p>Bien entendu, nous pouvons réutiliser nos composants dans de nouveaux
  composants et ainsi de suite (l'ordre n'a pas d'importance) :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;yield name="author_articles">
    &amp;lt;author_article />
    &amp;lt;hr />
  &amp;lt;/yield>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 id="art_(?id)">&amp;lt;value bind="?title" />&amp;lt;/h1>
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>

  &amp;lt;author_articles bind="?article" />
&amp;lt;/document></code></pre>
  <p>Enfin, utiliser un <strong>composant sélecteur</strong>, c'est à dire un
  composant <code>yield</code> avec l'attribut <code>select</code>, n'est
  possible que dans un composant nommé. L'objectif est de sélectionner des
  composants lors de l'utilisation d'un composant nommé. La sélection se fait à
  l'aide d'une <a href="http://w3.org/TR/xpath20">expression XPath</a> de la
  forme <code>?x[path]:<em>expression</em></code>. Par exemple, au lieu
  d'utiliser le composant <code>hr</code> de manière statique, nous allons
  sélectionner tous les composants fournis par l'utilisateur :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;yield name="author_articles">
    &amp;lt;author_article />
    &amp;lt;yield select="?x:*" />
  &amp;lt;/yield>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 id="art_(?id)">&amp;lt;value bind="?title" />&amp;lt;/h1>
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>

  &amp;lt;author_articles bind="?article">
    &amp;lt;p>&amp;lt;a href="#">top&amp;lt;/a>&amp;lt;/p>
    &amp;lt;hr />
  &amp;lt;/author_articles>
&amp;lt;/document></code></pre>


  <h3 id="Definition_de_bibliotheques_de_composants" for="main-toc">Définition
  de bibliothèques de composants</h3>

  <p>Nous savons créer des composants graphiques grâce aux composants nommés.
  Nous pouvons alors avoir des <strong>bibliothèques de composants
  graphiques</strong> stockées dans un ou plusieurs fichiers XYL.</p>
  <p><em>À l'instar</em> d'une déclaration de feuille de style ou d'un
  <em>overlay</em>, une utilisation d'une bibliothèque graphique se fait avec
  une <em>processing-instruction</em> : <code>&amp;amp;lt;?xyl-use?></code> en
  tête de n'importe quels documents XYL et avec son attribut <code>href</code>
  pour préciser l'emplacement de notre bibliothèque graphique. De même, pour une
  déclaration dynamique, nous avons la méthode <code>addUse</code> sur la classe
  <code>Hoa\Xyl</code>. Une bibliothèque peut bien sûr inclure d'autres
  bibliothèques et ainsi de suite. Une bibliothèque peut également déclarer des
  feuilles de style mais pas des <em>overlays</em>. Ainsi, si nous
  <strong>externalisons</strong> nos composants fraîchement créés :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-use href="Author.xyl"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;author_articles bind="?article">
    &amp;lt;p>&amp;lt;a href="#">top&amp;lt;/a>&amp;lt;/p>
    &amp;lt;hr />
  &amp;lt;/author_articles>
&amp;lt;/document></code></pre>
  <p>Enfin, notre bibliothèque graphique est contenue dans le <strong>composant
  racine</strong> <code>definition</code> et ne contient que des composants
  nommés. Voici notre fichier <code>Author.xyl</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;definition xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;yield name="author_articles">
    &amp;lt;author_article />
    &amp;lt;yield select="?x:*" />
  &amp;lt;/yield>

  &amp;lt;yield name="author_article">
    &amp;lt;h1 id="art_(?id)">&amp;lt;value bind="?title" />&amp;lt;/h1>
    &amp;lt;ul bind="?author">&amp;lt;li bind="?name" />&amp;lt;/ul>
  &amp;lt;/yield>
&amp;lt;/definition></code></pre>
  <p>Nous pouvons imaginer <strong>partager</strong> des bibliothèques entre
  <strong>plusieurs applications</strong> facilement ou même au sein d'une même
  application. La <strong>maintenance</strong> des composants graphiques se voit
  <strong>facilitée</strong> car tout est <strong>centralisé</strong> et
  facilement accessible. La <strong>composition</strong> des composants avec la
  <strong>propagation</strong> des liages vers les données offrent un mécanisme
  puissant. L'<strong>abstraction</strong> des données par leur caractère
  symbolique empêche des regressions.</p>

  <h2 id="Routeur_et_liens" for="main-toc menu-toc">Routeur et liens</h2>

  <p>Nous avons vu qu'une vue au sens de <code>Hoa\View\Viewable</code> comporte
  un <strong>routeur</strong>. Comme <code>Hoa\Xyl</code> implémente cette
  interface, nous pouvons définir et utiliser un routeur au sein de nos
  documents XYL.</p>
  <p>Nous allons commencer par écrire une règle sur un routeur HTTP et le donner
  à notre instance de XYL. La règle aura pour identifiant <code>blog</code>
  et n'aura aucune action (<ie /> <em>callable</em>) attachée. Nous voulons
  juste écrire un lien et non pas le reconnaître. Ainsi :</p>
  <pre><code language="php">from('Hoa')
-> import('File.Read')
-> import('Http.Response.~')
-> import('Xyl.~')
-> import('Xyl.Interpreter.Html.~')
-> import('Router.Http');

$router = new Hoa\Router\Http();
$router->get('blog', '/Blog/(?&amp;lt;id>\d+)-(?&amp;lt;title>[^\.]+)\.html');

$xyl    = new Hoa\Xyl(
    new Hoa\File\Read('Main.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html(),
    $router
);
$xyl->render();</code></pre>
  <p>Pour utiliser cette règle dans XYL, il faut tout d'abord se placer dans un
  attribut qui se comporte comme un <strong>lien</strong> (par exemple
  <code>href</code> pour le composant <code>&amp;amp;lt;a></code>,
  <code>src</code> pour le composant <code>&amp;amp;lt;img></code> etc.) et
  utiliser le formalisme suivant pour déclarer le lien :
  <code>@<em>anId</em>:<em>key</em>=<em>value</em>[&amp;amp;<em>key</em>=<em>value</em>]*</code>.
  Chaque <code><em>key</em></code> correspond à une <strong>variable</strong> de
  notre <strong>règle</strong> <code><em>anId</em></code> pour laquelle nous
  allons définir une <strong>valeur</strong> <code><em>value</em></code>. Ainsi,
  nous allons écrire le lien <code>@blog:id=42&amp;amp;title=Foobar</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>
&amp;lt;?xyl-stylesheet href="UI.css"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>First step with XYL&amp;lt;/title>

  &amp;lt;p>This is a link to &amp;lt;a href="@blog:id=42&amp;amp;amp;amp;title=Foobar">an article in my
  blog&amp;lt;/a>!&amp;lt;/p>
&amp;lt;/document></code></pre>
  <p>Le contenu de l'attribut <code>href</code> vaudra
  <code>/Blog/42-Foobar.html</code> après interprétation. Notre lien est bien
  créé. Maintenant, si nous modifions la règle pour autre chose mais toujours
  avec les variables <code>id</code> et <code>title</code> placées
  différemment (par exemple
  <code>/Blog/Article-(?&amp;amp;lt;title>[^\.]+)-(?&amp;amp;lt;id>\d+)\.html</code>),
  nous verrons le lien se réécrire automatiquement. Amusez-vous à supprimer des
  variables de votre règle pour voir comment elle réagit ; le mécanisme est
  assez intuitif.</p>
  <p>Notons que le « <code>&amp;amp;amp;amp;</code> » est obligatoire car écrire
  simplement « <code>&amp;amp;</code> » serait une source d'erreur lors de
  l'analyse du document XYL (qui est du XML).</p>


  <!-- Dans hoa://Data/… -->

  <h2 id="Application_Gordon-s_blog" for="main-toc menu-toc">Application :
  <em>Gordon's blog</em></h2>

  <ul class="prev_next">
    <li><a href="@ll:chapter=Model"><previous_chapter /> Modèle de
        données</a></li>
  </ul>

</yield>
</definition>
