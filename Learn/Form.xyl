<?xml version="1.0" encoding="utf-8"?>
<?xyl-use href="../Definitions.xyl"?>

<definition xmlns="http://hoa-project.net/xyl/xylophone">
<yield name="chapter">

  <h1 id="Form">Manuel d'apprentissage<title_break />Formulaire</h1>

  <ul class="prev_next">
    <li><a href="@ll:chapter=Xyl"><previous_chapter /> XYL</a></li>
    <li><a href="@ll:chapter=Fragment_async">Fragment et asynchrone
    <next_chapter /></a></li>
  </ul>

  <p>Les formulaires sont un des rares point d'interaction entre l'utilisateur
  et notre application. Dans ce chapitre, nous allons découvrir les mécanismes
  que propose XYL pour faciliter la manipulation des formulaires.</p>

  <h2 id="Table_des_matieres">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Introduction" for="main-toc">Introduction</h2>

  <p>Les formulaires sont un moyen donné à l'utilisateur pour entrer des
  données. Mais attention, il est bien connu que tout ce qui provient de
  l'utilisateur est potentiellement dangereux ou faux, il est donc nécessaire de
  valider toutes ces données. Par ailleurs, si nous lui demandons des données,
  c'est probablement pour les manipuler par la suite, ce qui doit pouvoir se
  faire facilement.</p>
  <p>Nous savons maintenant que les composants standards de XYL suivent le
  vocabulaire d'HTML. Les formulaires n'échappent pas à la règle même s'ils
  comportent des petits plus.</p>

  <h2 id="Ecrire_et_envoyer_un_formulaire" for="main-toc">Écrire et envoyer un
  formulaire</h2>

  <p>Nous allons écrire un formulaire très simple dans un fichier
  <code>Form.xyl</code> et utiliser les composants <code>form</code> ainsi que
  <code>input</code> :</p>
  <pre><code language="xml">&amp;lt;?xml version="1.0" encoding="utf-8"?>

&amp;lt;document xmlns="http://hoa-project.net/xyl/xylophone">
  &amp;lt;title>Form&amp;lt;/title>

  &amp;lt;form action="#" method="post" id="myForm">
    &amp;lt;p>Foo: &amp;lt;input type="text" name="foo" />&amp;lt;/p>
    &amp;lt;p>Bar: &amp;lt;input type="text" name="bar" />&amp;lt;/p>
    &amp;lt;p>&amp;lt;input type="submit" />&amp;lt;/p>
  &amp;lt;/form>

  &amp;lt;ul>
    &amp;lt;li bind="?result" />
  &amp;lt;/ul>
&amp;lt;/document></code></pre>
  <p>Pour envoyer un formulaire, il nous faut savoir vers quelle ressource
  seront transmises les données et avec quelle méthode HTTP. Ces informations
  sont présentes respectivement dans l'attribut <code>action</code> et
  <code>method</code>. Quand l'attribut <code>action</code> vaut <code>#</code>,
  cela signifie que les données seront envoyées sur l'URI courant. Aucune
  différence avec les formulaires en HTML !</p>

  <h2 id="Recuperation_des_donnees" for="main-toc">Récupération des données</h2>

  <p>Nous allons maintenant écrire l'interpréteur XYL pour ce document. Dans un
  premier temps, affichons simplement le formulaire, puis nous verrons comment
  récupérer les données par la suite. Ainsi, dans un fichier
  <code>index.php</code> :</p>
  <pre><code language="php">from('Hoa')
-> import('File.Read')
-> import('Http.Response')
-> import('Xyl.~')
-> import('Xyl.Interpreter.Html.~');

$xyl = new Hoa\Xyl(
    new Hoa\File\Read('Form.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html()
);
$xyl->render();</code></pre>
  <p>Avec ceci, le formulaire s'affichera. Nous connaissons déjà très bien cette
  opération. Maintenant, nous savons que quand le formulaire sera envoyé, ce
  sera ce même code qui va s'exécuter. Nous voulons que notre composant
  <code>ul</code> contiennent les données. Pour cela, nous allons procéder en
  trois étapes :</p>
  <ul>
    <li>récupérer notre formulaire ;</li>
    <li>vérifier s'il est valide ;</li>
    <li>liéer les données avec notre liste.</li>
  </ul>
  <p>Comme pour les fragments, nous allons découper le rendu en deux pour faire
  tout d'abord l'interprétation du document, puis récupérer notre formulaire, le
  reste des opérations, et enfin terminer sur le rendu.</p>
  <p>Pour récupérer notre formulaire, nous allons utiliser la méthode
  <code>Hoa\Xyl::getElement</code> qui prend en argument l'identifiant d'un
  élément. Nous allons nous en servir pour récupérer notre formulaire. Ensuite,
  une fois que nous l'aurons, nous pourrons appeler les méthodes
  <code>Hoa\Xyl\Interpreter\Html\Form::hasBeenSent</code> et
  <code>Hoa\Xyl\Interpreter\Html\Form::isValid</code>, respectivement pour
  savoir si le formulaire a été envoyé et s'il est valide. Attention, les
  données ne seront pas disponibles tant qu'elles n'auront pas été validées.
  Enfin, si toutes ces contraintes sont respectées, alors nous récupérerons les
  données avec la méthode
  <code>Hoa\Xyl\Interpreter\Html\Form::getFormData</code> ; ainsi :</p>
  <pre><code language="php">$xyl = new Hoa\Xyl(
    new Hoa\File\Read('Form.xyl'),
    new Hoa\Http\Response(),
    new Hoa\Xyl\Interpreter\Html()
);
$xyl->interprete();
$data = $xyl->getData();
$form = $xyl->getElement('myForm');

if(   true === $form->hasBeenSent()
   &amp;amp;&amp;amp; true === $form->isValid())
    $data->result = array_values($form->getFormData());

$xyl->render();</code></pre>
  <p>Nous pouvons tester que notre formulaire fonctionne bien. Nous remarquons
  que les données sont persistantes dans le formulaire, c'est à dire qu'elles
  sont automatiquement replacées dans les champs correspondants (et ce n'est pas
  réservé au composant <code>input</code>, mais aussi à <code>select</code>,
  <code>textarea</code> etc.).</p>

  <h2 id="Contraintes_et_erreurs" for="main-toc">Contraintes et erreurs</h2>

  <p>Nous avons parlé de validité du formulaire. Le premier niveau de validité
  est celui introduit par HTML. Par exemple, l'extrait suivant exprime la
  contrainte : « la taille du texte est comprise entre 0 et 42 ».</p>
  <pre><code language="xml">&amp;lt;input type="text" maxlength="42" /></code></pre>
  <p>L'exemple suivant exprime : « mon nombre est compris entre 7 et 42 » :</p>
  <pre><code language="xml">&amp;lt;input type="range" min="7" max="42" /></code></pre>
  <p>L'exemple suivant exprime : « ma donnée est une adresse email » :</p>
  <pre><code language="xml">&amp;lt;input type="email" /></code></pre>
  <p>Et ainsi de suite. HTML propose une expressivité déjà importante. Côté
  client, ce sont les navigateurs qui sont chargés de ces validations pour
  fournir un retour immédiat à l'utilisateur. Côté serveur, c'est XYL qui se
  charge de ces validations (car les données ne proviennent pas toujours d'un
  navigateur, rappelez-vous qu'il ne faut jamais faire confiance à
  l'utilisateur).</p>
  <p>Très souvent, nous souhaitons associer des erreurs à une validation. C'est
  le rôle de l'attribut <code>error</code> présents sur tous les éléments de
  formulaires pouvant être soumis (comme <code>input</code>,
  <code>button</code>, <code>select</code>, <code>textarea</code>,
  <code>keygen</code> etc.). Cet attribut contient une liste d'identifiants
  séparés par des espaces (comme pour l'attribut <code>class</code>). Ces
  identifiants réfèrent des composants <code>error</code>. Ces composants, par
  défaut, ne sont pas peints, sauf si une erreur survient et qu'elle change sa
  visibilité. Ils peuvent contenir absolument n'importe quoi et peuvent être
  placés n'importe où. Par exemple :</p>
  <pre><code language="xml">&amp;lt;input type="email" error="myError" />
…
&amp;lt;error id="myError">
  &amp;lt;p>I am an error!&amp;lt;/p>
&amp;lt;error></code></pre>

  <!--
  <p>Maintenant, nous aimerions ajouter des contraintes sur les entrées du
  formulaire. Nous allons nous aider de l'attribut <code>validate</code>. Dans
  cet attribut, nous allons écrire du code Praspel (que nous décrirons plus
  tard, nous allons donner un exemple pour illustrer). Par exemple, nous allons
  dire que l'entrée <code>foo</code> doit être un entier entre 0 et 255,
  ainsi :</p>
  <pre><code language="xml">&amp;lt;input type="text" name="foo" validate="boundinteger(0, 255)" /></code></pre>
  <p>Si nous entrons <code>hello</code> dans notre entrée, le formulaire ne sera
  pas valide et nous ne verrons pas le résultat. En revanche, si nous entrons
  <code>42</code>, alors le résultat apparaîtra car le formulaire est
  valide ! Très bien, mais nous aimerions afficher une erreur si la validation
  échoue. Nous pouvons utiliser l'attribut <code>onerror</code> sur notre champ
  mais nous pouvons également utiliser le composant <code>error</code>. Les deux
  sont liés à travers l'identifiant du composant <code>error</code>. Nous
  pouvons placer ce composant où nous le voulons, il n'apparaîtra pas tant
  qu'une erreur ne sera pas survenue :</p>
  <pre><code language="xml">&amp;lt;input type="text" name="foo" validate="boundinteger(0, 255)" onerror="e_foo" /></code></pre>
  <p>Et autre part :</p>
  <pre><code language="xml">&amp;lt;error id="e_foo">
  foo must be an integer between 0 and 255.
&amp;lt;/error></code></pre>
  <p>Essayons d'entrer <code>hello</code> à nouveau et nous verrons l'erreur
  apparaître.</p>
  <p>C'est un bon début mais il arrive souvent que nous ayons plusieurs erreurs
  possibles pour une même entrée. Nous pouvons alors écrire plusieurs attributes
  <code>validate-<em>suffix</em></code> et
  <code>onerror-<em>suffix</em></code>.</p>
  -->

  <!-- validate-x & onerror-x forment une disjonction et pas une conjonction,
       refaire le système et factoriser le code. -->
  <!-- @novalidate -->

  <ul class="prev_next">
    <li><a href="@ll:chapter=Xyl"><previous_chapter /> XYL</a></li>
    <li><a href="@ll:chapter=Fragment_async">Fragment et asynchrone
    <next_chapter /></a></li>
  </ul>

</yield>
</definition>
