<?xml version="1.0" encoding="utf-8"?>
<?xyl-use href="../Definitions.xyl"?>

<definition xmlns="http://hoa-project.net/xyl/xylophone">
<yield name="chapter">

  <h1 id="Model">Manuel d'apprentissage<title_break />Modèle de données</h1>

  <ul class="prev_next">
    <li><a href="@ll:chapter=Routerdispatcher"><previous_chapter /> Router +
        Dispatcher = ♥</a></li>
  </ul>

  <p>Une part importante d'une application est la <strong>manipulation des
  données</strong>, sa facilité, son uniformité et sa pérennité. Dans ce
  chapitre, nous allons présenter la bibliothèque <code>Hoa\Database</code>
  ainsi que <code>Hoa\Model</code>.</p>

  <h2 id="Table_des_matieres" for="menu-toc">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Base_de_donnees" for="main-toc menu-toc">Base de données</h2>

  <p>Les bases de données sont des outils permettant de stocker et d'extraire
  des données de différentes formes et de différentes tailles.  Nous parlons
  plutôt de gestionnaires de base de données. Nous pouvons distinguer deux
  familles de bases de données : relationnelles et objets. Actuellement, les
  usages les plus courants se tournent vers des bases de données relationnelles
  qui utilisent la théorie des ensembles pour stocker et extraire leurs
  données.</p>
  <p>Le langage <strong>SQL</strong> (pour <em>Structured Query Language</em>)
  permet de communiquer avec ces bases de données. Plusieurs standards ont été
  dictés, comme les normes
  <a href="https://secure.wikimedia.org/wikipedia/en/wiki/SQL-92">SQL-92</a>
  (ou SQL2) et
  <a href="https://secure.wikimedia.org/wikipedia/en/wiki/SQL:1999">SQL-99</a>
  (ou SQL3) pour ne citer que les plus connues et répandues. Le langage SQL est
  partagé en quatre objectifs :</p>
  <ul>
    <li>DDL (pour <em>Data Definition Language</em>) permet d'ajouter, de
    modifier ou de supprimer des définitions de tables (<code>CREATE
    TABLE</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code> …) ;</li>
    <li>DML (pour <em>Data Manipulation Language</em>) permet de sélectionner,
    d'insérer, de mettre à jour ou de supprimer des données d'une table
    (<code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code>,
    <code>SELECT</code> …) ;</li>
    <li>DCL (pour <em>Data Control Language</em>) permet de gérer les droits
    d'accès aux données (<code>GRANT</code>, <code>DENY</code>,
    <code>REVOKE</code> …).</li>
  </ul>
  <p>La structure des données est appelée un <strong>schéma</strong>.</p>
  <p>Dans une application, pour communiquer avec un gestionnaire de base de
  données, nous devrons nous y connecter, puis y exécuter des requêtes (à l'aide
  du langage SQL). La base de données nous calculera un résultat qu'elle nous
  renverra et que nous pourrons exploiter. Le maximum de calculs doit être
  effectué par la base de données qui est optimisée dans ce type de tralient !
  Nous verrons par la suite comme faciliter l'exploitation de ces données qui
  peut devenir un processus complexe si le schéma des données évolue ou n'est
  pas trivial.</p>

  <h3 id="Abstraction_des_diverses_bases_de_donnees" for="main-toc">Abstraction
  des diverses bases de données</h3>

  <p>Chaque gestionnaire de base de données fournit un pilote pour pouvoir
  communiquer avec sa base de données. Comme aucun standard n'existe pour ces
  pilotes, ils sont tous différents les uns des autres. Cela peut se comprendre
  car ils n'apportent pas tous le même degré d'optimisation selon les usages.
  Cependant, nous aimerions avoir une utilisation uniforme de tous ces pilotes.
  C'est pourquoi il existe des <strong>couches d'abstraction de bases de
  données</strong>, ou DBAL (pour <em>Database Abstract Layer</em>). PHP en
  propose une : <a href="http://php.net/book.pdo">PDO</a> (pour <em>PHP Data
  Objects</em>), mais il en existe d'autres, comme par exemple :
  <a href="msdn.microsoft.com/fr-fr/library/ms710252(v=VS.85).aspx">ODBC</a>
  (pour <em>Open Database Connectivity</em>).</p>
  <p>Hoa définit une couche d'abstraction par dessus ces couches d'abstraction,
  grâce aux classes <code>Hoa\Database\Dal</code> et
  <code>Hoa\Database\DalStatement</code>. Cette couche d'abstraction permet
  simplement de choisir quelle couche nous voulons utiliser (ou alors plonger
  directement sur un pilote sans passer par une couche d'abstraction).</p>
  <p>Dans un premier temps, nous conseillons d'utiliser PDO car c'est une couche
  native à PHP qui ne nécessite aucune installation particulière.  Dans la suite
  de ce chapitre, nous allons utiliser PDO avec le gestionnaire de base de
  données <a href="http://sqlite.org/">SQLite</a>, lui aussi intégré à PHP
  (ainsi qu'à de <a href="http://sqlite.org/famous.html">nombreux outils</a>).
  Ce dernier est très léger et travaille sur des fichiers contenant des petites
  base de données, ce qui le rend portable.</p>
  <p>Pour illuster les premiers exemples, nous allons créer une petite base de
  données et la pré-remplir de quelques données. Dans un fichier, n'importe où
  (par exemple <code>/tmp/foo)</code>, nous écrivons nos requêtes SQL :</p>
  <pre><code language="sql">CREATE TABLE user (
    id INTEGER PRIMARY KEY ASC AUTOINCREMENT,
    firstname VARCHAR(32),
    lastname VARCHAR(32),
    birthday INTEGER
);

INSERT INTO user VALUES ( NULL, 'Gordon', 'Freeman', 1973 );
INSERT INTO user VALUES ( NULL, 'Alyx',   'Vance',   1995 );
INSERT INTO user VALUES ( NULL, 'Cave',   'Johnson', 1947 );</code></pre>
  <p>Puis nous allons créer notre base de données :</p>
  <pre><code language="shell">$ sqlite3 -init /tmp/foo -echo /var/db/Foo.sqlite
// … our queries.</code></pre>

  <h3 id="Se_connecter_a_une_base_de_donnees" for="main-toc">Se connecter à une
  base de données</h3>

  <p>Une application peut vouloir communiquer avec plusieurs bases de données.
  C'est pourquoi la classe <code>Hoa\Database\Dal</code> définit une liste de
  profils de connexions potentielles représentés par des identifiants uniques.
  Chaque profil de connexion est une structure qui porte les données
  suivantes :</p>
  <ul>
    <li><code>id</code>, unique et représente le profil ;</li>
    <li><code>dsn</code> (pour <em>Data Source Name</em>), décrit une connexion
    vers une base de données (spécifique à chaque DBAL) ;</li>
    <li><code>username</code>, un nom d'utilisateur pour se connecter à la base
    de données (inutile avec SQLite) ;</li>
    <li><code>password</code>, un mot de passe se couplant avec le nom
    d'utilisateur (inutile avec SQLite) ;</li>
    <li><code>options</code>, un tableau d'options spécifiques au gestionnaire
    de base de données utilisé.</li>
  </ul>

  <p>Cette liste de profils fait partie des paramètres de notre classe à partir
  de <code>Hoa\Core\Parameter</code> (une des couches du noyau).  Toutefois,
  <code>Hoa\Database\Dal</code> étant un multiton un peu particulier (comme nous
  le verrons rapidement), une méthode intermédiaire est proposée pour
  initialiser les paramètres de cette classe : <code>initializeParameters</code>
  Par exemple, si nous utilisons une base de données SQLite située dans le
  fichier <code>/var/db/Foo.sqlite</code> sous le profil <code>default</code>,
  alors nous aurons le code suivant :</p>
  <pre><code language="php">from('Hoa')
-> import('Database.Dal');

Hoa\Database\Dal::initializeParameters(array(
    'connection.list.default.dal' => Hoa\Database\Dal::PDO,
    'connection.list.default.dsn' => 'sqlite:/var/db/Foo.sqlite'
));</code></pre>

  <p>Toutefois, dans une application, la connexion vers une base de données
  peut être difficile à retrouver. En effet, les applications sont de plus
  en plus découpées et il est difficile de conserver un chemin vers notre
  connexion. C'est pourquoi <code>Hoa\Database\Dal</code> propose la méthode
  <code>getInstance</code> qui permet de retrouver la connexion associée à
  un identifiant ou de l'ouvrir si c'est la première fois. Ainsi, nous
  ferons :</p>
  <pre><code language="php">Hoa\Database\Dal::getInstance('default');</code></pre>
  <p>Mais il existe aussi des cas où nous voulons simplement utiliser la
  connexion courante sans savoir laquelle c'est, en particulier si nous
  manipulons plusieurs connexions en même temps. C'est pourquoi
  <code>Hoa\Database\Dal</code> définit la méthode <code>getLastInstance</code>
  (d'arité nulle). Cette méthode va retrouver la dernière connexion utilisée.
  Toutefois, si aucune n'a été précédemment ouverte, il serait agréable qu'elle
  sache en ouvrir une. C'est pourquoi <code>Hoa\Database\Dal</code> propopose le
  paramètre <code>connexion.autoload</code> pour choisir un profil à charger par
  défaut. L'exemple suivant va enrichir les paramètres que nous avons déjà
  écrits puis ouvrir la connexion attachée au profil <code>default</code> comme
  si la connexion avait déjà été ouverte :</p>
  <pre><code language="php">Hoa\Database\Dal::initializeParameters(array(
    'connection.list.default.dal' => Hoa\Database\Dal::PDO,
    'connection.list.default.dsn' => 'sqlite:/var/db/Foo.sqlite',
    'connection.autoload'         => 'default'
));

// Open profile “default”.
$connexion = Hoa\Database\Dal::getLastInstance();</code></pre>
  <p>Les avantages sont nombreux : plus besoin de garder un lien vers une
  connexion de base de données, plus besoin de savoir quel profil a été utilisé
  dernièrement pour re-travailler dessus, plus besoin de se reconnecter en
  cherchant à nouveau les options etc.</p>

  <h3 id="Executer_des_requetes_sur_une_base_de_donnees" for="main-toc">Exécuter
  des requêtes sur une base de données</h3>

  <p>Exécuter une requête sur une base de données suit en général les étapes
  suivantes : écrire une requête complète ou pas, la compléter si nécessaire,
  l'exécuter puis récupérer les résultats. Pour exécuter écrire et exécuter une
  requête directement, nous pouvons utiliser la méthode
  <code>Hoa\Database\Dal::query</code> qui prend en seul argument une requête
  SQL. Exécuter une requête va nous retourner un objet de type
  <code>Hoa\Database\DalStatement</code> qui représente une requête d'une
  manière générale. Pour récupérer les résultats de notre requête, nous
  utiliserons la méthode <code>Hoa\Database\DalStatement::fetchAll</code>.
  Ainsi :</p>
  <pre><code language="php">$dal       = Hoa\Database\Dal::getLastInstance();
$statement = $dal->query('SELECT * FROM foo LIMIT 2');
print_r($statement->fetchAll());

// Will output:
// Array
// (
//     [0] => Array
//         (
//             [id] => 1
//             [firstname] => Gordon
//             [lastname] => Freeman
//             [birthday] => 1973
//         )
//
//     [1] => Array
//         (
//             [id] => 2
//             [firstname] => Alyx
//             [lastname] => Vance
//             [birthday] => 1995
//         )
//
// )</code></pre>
  <p>Le résultat ici est un tableau des tuples indexés par notre sélection.</p>
  <p>Maintenant, imaginons que nous souhaitons que la limite (ici le nombre
  maximum de tuples à sélectionner) soit variable : nous pouvons soit construire
  la requête par concaténation à une variable <code>$limit</code>, soit en
  utilisant des requêtes préparées. Les avantages des requêtes préparées sont
  tout d'abord une optimisation de la part du gestionnaire de base de données
  mais aussi une meilleure sécurité.  En effet, les paramètres (ou les
  variables) d'une requête SQL sont protégés automatiquement, il est donc
  toujours préférable d'utiliser ce mécanisme.  Pour exécuter une requête
  paramétrée, nous devons commencer par la préparer à l'aide de la méthode
  <code>Hoa\Database\Dal::prepare</code> qui retourne un objet
  <code>Hoa\Database\DalStatement</code> comme attendu.  Puis nous l'exécutons à
  l'aide de la méthode <code>Hoa\Database\DalStatement::execute</code>, qui, en
  argument, reçoit un tableau de valeurs pour chaque paramètre. Les paramètres
  sont préfixés par deux-points (le symbole « <code>:</code> ») et ne doivent
  pas contenir d'espaces. Voyons plutôt :</p>
  <pre><code language="php">$dal       = Hoa\Database\Dal::getLastInstance();
$statement = $dal->prepare('SELECT * FROM foo LIMIT :my_limit');
$limit     = 2;
$statement->execute(array('my_limit' => $limit));
print_r($statement->fetchAll());</code></pre>
  <p>Mieux encore, au lieu de préciser la valeur des paramètres dans la méthode
  <code>execute</code>, nous pouvons utiliser la méthode
  <code>Hoa\Database\Dal::bindParameter</code> qui permet de faire des choses
  intéressantes. Nous ne verrons que deux des quatres arguments disponibles, qui
  permettent d'associer une valeur à un paramètre :</p>
  <pre><code language="php">$statement = $dal->prepare('SELECT * FROM foo LIMIT :my_limit');
$limit     = 2;
$statement->bindParameter('my_limit', $limit);
$statement->execute();</code></pre>
  <p>Ce qui est intéressant est que la variable qui porte la valeur du paramètre
  est passée en référence ! Ce qui signifie que tant que nous n'avons pas
  exécuter la requête, nos paramètres sont modifiables en modifiant simplement
  la valeur de cette variable (<ie /> pas besoin d'appeler à nouveau la méthode
  <code>bindParameter</code>) :</p>
  <pre><code language="php">$statement = $dal->prepare('SELECT * FROM foo LIMIT :my_limit');
$limit     = 1;
$statement->bindParameter('my_limit', $limit);
++$limit; // $limit and :my_limit are now set to 2.
$statement->execute();</code></pre>
  <p>Et même après exécution de notre requête, nous pouvons modifier un
  paramètre et ré-exécuter notre requête, sur le même objet
  <code>Hoa\Database\Dal</code>. Le gestionnaire de base de données quant à lui
  doit être en mesure de fournir des optimisations pour calculer plus rapidement
  le résultat attendu (parfois même faire du cache paramétré). Ce mécanisme
  n'est pas à négliger lorsque nous avons des requêtes paramétrées (<ie />
  contenant des valeurs variables).</p>

  <h3 id="Bien_plus_d-operations" for="main-toc">Bien plus d'opérations</h3>

  <p>La bibliothèque <code>Hoa\Database</code> propose bien d'autres
  opérations comme la gestion des transactions, quelques opérations sur les
  identifiants, d'autres sur la sécurité, les erreurs etc. Nous n'allons pas
  tout détailler ici.</p>

  <h2 id="Modeliser_des_donnees" for="main-toc menu-toc">Modéliser des
  données</h2>

  <p>L'Informatique est la science de l'information. Le meilleur moyen de se
  représenter une information est de la modéliser. Une modélisation ne
  correspond pas toujours à l'implémentation de l'information, <ie /> la
  représentation de l'information lors de son utilisation peut différer de sa
  modélisation mais peu importe. Une information bien modéliser permet de mieux
  se la représenter et ainsi pouvoir raisonner automatiquement dessus.  Par
  exemple, selon la précision des informations portées par le modèle, nous
  pouvons automatiser la génération de données de tests ou carrément de
  tests !</p>

  <h3 id="Premier_pas_avec_un_modele" for="main-toc">Premier pas avec un
  modèle</h3>

  <p>Il y a plusieurs façon de représenter un modèle : soit textuellement avec
  du code, soit graphiquement (graphiques qui seront probablement compilés vers
  du code). Nous avons fait le choix de représenter un modèle avec du code, à
  travers la bibliothèque <code>Hoa\Model</code>. Nous profitons du paradigme
  objet de PHP en choisissant de représenter chaque élément du modèle par une
  classe, et ainsi, les données sont portées par les attributs de classes. Par
  exemple pour représenter un utilisateur qui a un identifiant, un prénom, un
  nom et un âge, nous aurions :</p>
  <pre><code language="php">from('Hoa')
-> import('Model.~');

class User extends Hoa\Model {

    public $_id;
    public $_firstname;
    public $_lastname;
    public $_birthday;
}</code></pre>
  <p>Pour instancier un utilisateur, nous allons travailler sur ses attributs en
  faisant abstraction du <em>underscore</em> (le symbole « <code>_</code> »),
  ainsi :</p>
  <pre><code language="php">$user     = new User();
$user->id = 42;
var_dump($user->id);

// Will output:
//     int(42)</code></pre>
  <p>C'est un bon début mais c'est très naïf. Nous aimerions faire le lien entre
  modèle et données.</p>

  <h3 id="Lien_entre_modele_et_donnees" for="main-toc">Lien entre modèle et
  données</h3>

  <p>Un modèle représente une information, ou plutôt un ensemble de données.
  Ces données peuvent venir de plusieurs endroits différents, peu importe d'où.
  C'est pourquoi <code>Hoa\Model</code> propose entre autre un mécanisme pour
  ouvrir un modèle et l'enregistrer. À l'utilisateur ensuite d'écrire le lien
  entre son modèle et ses données.</p>
  <p>Commençons par la méthode qui permet d'ouvrir un modèle : <code>open</code>
  qui prend en argument un tableau de contraintes portant par exemple sur les
  attributs (ce sera la sémantique la plus répandue pour les contraintes mais
  rien ne nous empêche d'en donner une autre). Nous allons utiliser les données
  stocker dans <code>/var/db/Foo.sqlite</code> à travers
  <code>Hoa\Database</code> pour les extraire, que nous devons définir comme
  lien — ou <em>mapping layer</em> — dans le constructeur spécial
  <code>construct</code>. Enfin, nous allons effectuer le lien entre les données
  extraites et notre modèle grâce à la méthode <code>map</code> :</p>
  <pre><code language="php">from('Hoa')
-> import('Model.~')
-> import('Model.Exception')
-> import('Database.Dal');

class User extends Hoa\Model {

    public $_id;
    public $_firstname;
    public $_lastname;
    public $_birthday;

    public function construct ( ) {

        // 1. set mapping layer.
        $this->setMappingLayer(Hoa\Database\Dal::getLastInstance());

        return;
    }

    public function open ( Array $constraints = array() ) {

        // 2. ensure that the constraint “id” exists.
        if(!isset($constraints['id']))
            throw new Hoa\Model\Exception('The constraint “id” is needed.', 0);

        // 3. extract data.
        $data = $this->getMappingLayer()
                     ->prepare(
                         'SELECT id, firstname, lastname, birthday ' .
                         'FROM   user ' .
                         'WHERE  id = :id'
                     )
                     ->execute($constraints)
                     ->fetchAll();

        // 4. map data to our model.
        $this->map($data[0]);

        return;
    }
}</code></pre>
  <p>Nous pouvons tester ce modèle de cette façon :</p>
  <pre><code language="php">$user = new User();
$user->open(array('id' => 1));
var_dump($user->firsname);

// Will output:
//     string(6) "Gordon"</code></pre>
  <p>Il existe une autre manière de définir des contraintes en définissant des
  valeurs aux attributs avant d'ouvrir le modèle. Pour cela, nous devons
  fusionner les contraintes données dans la méthode <code>open</code> (si
  jamais) avec les contraintes définies par les attributs. Nous ajoutons alors
  juste avant le point 2 :</p>
  <pre><code language="php">$constraints = array_merge($constraints, $this->getConstraints());</code></pre>
  <p>Puis, pour arriver au même résultat que précédemment :</p>
  <pre><code language="php">$user     = new User();
$user->id = 1;
$user->open();
var_dump($user->firstname);</code></pre>

  <h3 id="Validation_des_donnees" for="main-toc">Validation des données</h3>

  <p>Avant d'enregistrer de nouvelles données, nous devons les valider.  C'est
  pourquoi <code>Hoa\Model</code> propose un mécanisme de validatation
  dynamique. En effet, à chaque donnée du modèle, <ie /> à chaque attribut, nous
  pouvons associer une méthode de validation dont la convention de nommage est
  <code>validate<em>Data</em></code> et qui prend en unique argument une valeur.
  Cette méthode se comporte comme un prédicat, <ie /> une fonction qui retourne
  <code>true</code> ou <code>false</code>.  L'assignation de la valeur à la
  donnée ne s'effectue pas dans les méthodes de validations.</p>
  <p>Précisons pour la convention de nommage que l'attribut
  <code>aBc_DeF_GHI</code> sera renommée <code>AbcDefGhi</code> pour s'ajouter
  au nom de la méthode de validation (nous faisons une transformation vers du <a
  href="https://en.wikipedia.org/wiki/CamelCase">CamelCase</a>).</p>
  <p>Ainsi, si nous voulons ajouter une validation sur la date de naissance qui
  doit être compris entre 0 et l'année courante, nous ferions :</p>
  <pre><code language="php">public function validateBirthday ( $birthday ) {

    return 0 &amp;lt;= $age &amp;amp;&amp;amp; ((int) date('Y')) >= $birthday;
}</code></pre>
  <p>Si nous testons notre validateur en assignant des valeurs à la donnée
  <code>birthday</code>, nous aurons :</p>
  <pre><code language="php">$user           = new User();
$user->birthday = 1973;  // all right.
$user->birthday = 65537; // an exception is thrown.</code></pre>
  <!-- 65537 is a Fermat number (2^2^n + 1) -->
  <p>Nous pouvons désactiver la validation à l'aide de la méthode
  <code>setEnableValidation</code> de cette manière :</p>
  <pre><code language="php">$user->setEnableVaidation(false);</code></pre>
  <p>Notons que comme notre modèle est représenté par un ensemble de classe,
  nous pouvons avoir de l'héritage et ainsi hériter des propriétés de
  validations. Nous sommes ainsi capable d'en surcharger certaines et d'y
  ajouter des contraintes. Cela peut être mécanisme intéressant à ne pas
  négliger.</p>

  <h3 id="Un_peu_de_Praspel_pour_valider_et_meme_plus" for="main-toc">Un peu de
  Praspel pour valider et même plus</h3>

  <p>Dans l'optique d'automatiser la génération de tests, Hoa propose le langage
  <strong>Praspel</strong>. Ce dernier repose sur des structures algébriques,
  avec des propriétés particulières, appelées <strong>domaines
  réalistes</strong>. Praspel exploite le paradigme des contrats à travers
  plusieurs clauses (<ie /> plusieurs contraintes formelles). Il est prématuré
  d'expliquer Praspel dans ce chapitre et c'est pourquoi nous allons nous
  restreindre à une clause particulière : <code>@invariant</code> pour spécifier
  les données portées par notre modèle.</p>
  <p>Praspel permet d'utiliser les domaines réalistes de manière simple et
  permet de caractériser assez finement la forme des données. Dans la majorité
  des cas, une clause Praspel peut remplacer une méthode validation vue
  précédémment. L'idée est alors d'écrire des méthodes de validations pour
  ajouter des contraintes supplémentaires sur la forme des données uniquement.
  Notons qu'il est très facile d'écrire son propre domaine réaliste (voir la
  bibliothèque <code>Hoa\Realdom</code>) et qu'il est préférable de passer par
  là s'il sera utilisé souvent car les domaines réalistes offrent deux
  propriétés intéressants qui sont la <em>prédicabilité</em> (vérification) et
  <em>générabilité</em> (génération). En effet, nous sommes capable de générer
  des données automatiquement et si notre modèle est <strong>annoté</strong>
  avec le langage Praspel, nous pourrons générer automatiquement des données
  pour remplir notre modèle. Les conséquences immédiates sont : construire
  plusieurs modèles valides rapidement, l'enregistrer et ainsi construire des
  données (par exemple remplir une base de données) ou générer des cas de tests
  automatiquement.</p>
  <p>Même si nous n'expliquons pas Praspel dans le détail, nous allons montrer
  comment valider notre modèle :</p>
  <pre><code language="php">class User extends Hoa\Model {

    /**
     * @invariant id: boundinteger(1);
     */
    public $_id;

    /**
     * @invariant firstname: regex('[\w\'\- ]{1,42}');
     */
    public $_firstname;

    /**
     * @invariant firstname: regex('[\w\'\- ]{1,42}');
     */
    public $_lastname;

    /**
     * @invariant birthday: date('Y', boundinteger(0, timestamp('now')));
     */
    public $_birthday;

    // …
}</code></pre>
  <p>Nous rappelons que les méthodes <code>validate<em>Data</em></code> peuvent
  venir en soutient à Praspel. Nous rappelons également que nous sommes sur des
  exemples simples et que Praspel peut exprimer des contraintes plus fines que
  ça.</p>

  <h3 id="Gerer_les_relations" for="main-toc">Gérer les relations</h3>

  <p>Les relations entre les différentes parties du modèle sont une composante à
  ne pas négliger. En effet, si nous avons notre élément <code>User</code> qui
  peut être relié à disons l'élément <code>Mail</code>. Cette relation peut
  avoir une arité et un sens : par exemple « combien de mails un utilisateur
  peut avoir ? ».</p>
  <p>Une relation en Praspel s'exprime avec le domaine réaliste
  <code>relation</code> qui est une simplification syntaxique d'une domaine
  réaliste <code>array</code>. Nous devons préciser à quel élément du modèle est
  relié notre élément courant et son arité. Par exemple, pour dire qu'« un
  utilisateur peut avoir zéro ou vingts mails », nous écririons :</p>
  <pre><code language="php">/**
 * @invariant mails: relation('Mail', boundinteger(0, 20));
 */
public $mails;</code></pre>
  <p>Enfin, pour faire le lien entre les données et la relation de notre modèle,
  nous n'utiliserons pas la méthode <code>map</code> mais
  <code>mapRelation</code> qui fonctionne de manière assez similaire. Nous
  allons détaillé ce point dans notre application <code>Gordon's
  blog</code>.</p>

  <h2 id="Application_Gordon-s_blog" for="main-toc menu-toc">Application :
  <em>Gordon's blog</em></h2>

  <h3 id="Schema_des_donnees" for="main-toc">Schéma des données</h3>

  <h3 id="Modele_des_donnees" for="main-toc">Modèle des données</h3>

  <h3 id="Depuis_un_controleur" for="main-toc">Depuis un contrôleur</h3>

  <ul class="prev_next">
    <li><a href="@ll:chapter=Routerdispatcher"><previous_chapter /> Router +
        Dispatcher = ♥</a></li>
  </ul>

</yield>
</definition>
